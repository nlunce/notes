{
  "hash": "6cd930871974d716c3a1881e46901a9b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'REALITY CHECK 05'\nauthor: 'Nathan Lunceford'\nformat:\n  html:\n    self-contained: true\n    page-layout: full\n    toc: true\n    toc-depth: 1\n    toc-location: left\n    number-sections: false\n    html-math-method: katex\n    code-overflow: wrap\n    code-copy: hover\n    code-tools:\n      source: false\n      toggle: false\n      caption: See code\nexecute:\n  warning: false\n  message: false\n---\n\n\n# **OVERVIEW**\n\nThe use of **Adaptive Quadrature** is essential for maintaining constant speed along a specific path. This is a requirement in fields like computer-aided manufacturing, robotics and animation. Smooth and controlled movement is crucial for accuracy, but achieving a constant speed along a curved or complex path is challenging. Dividing a path into equal time intervals does not ensure equal-distance segments because the path’s shape influences the distance covered.\n\nTo address this, numerical methods are employed to divide the path into equal arc-length segments, ensuring consistent movement. The process involves several key steps:\n\n1. **Arc Length Measurement**: The total length of the path is calculated using parametric equations, accounting for all curves and directional changes. This measurement provides the foundation for precise segmentation.\n\n2. **Mapping Path Position**: To locate a point at a given distance $s$ along the path, the corresponding parameter $t$ is determined using numerical methods like Bisection or Newton’s Method. This ensures precise mapping of arc-length positions to their parametric coordinates.\n3. **Segmenting the Path**: The path is divided into segments of equal arc length, a process called equipartitioning. This segmentation ensures uniformity in the spacing of points along the path, regardless of its complexity or curvature.\n\n4. **Smooth Traversal**: Animations or simulations often demonstrate the practical effects of this approach. By comparing movement at constant parameter speed with movement along equal arc-length segments, the benefits of consistent, controlled traversal become clear, showcasing smoother and more predictable motion.\n\n# **PROBLEM 01**\n\n---\n\n### **Problem Statement**\n\nWrite a Python function that computes the arc length of the path $P$ from $t = 0$ to $t = s$ for a given $0 \\leq s \\leq 1$. The choice of numerical integration method is up to you.\n\nThe path $P$ is defined as:\n\n$$\nP = \\begin{cases}\nx(t) = 0.5 + 0.3t + 3.9t^2 - 4.7t^3 \\\\\ny(t) = 1.5 + 0.3t + 0.9t^2 - 2.7t^3\n\\end{cases}\n$$\n\n### **Objective and Approach**\n\nThe objective is to calculate the arc length, or total distance, along the path defined by $x(t)$ and $y(t)$ as $t$ moves from 0 to $s$, where $s$ is between 0 and 1. The arc length is not simply the straight-line distance between the start and end points, as the path may curve or change direction.\n\nTo accurately determine the distance traveled along the path, the following arc length formula is used:\n\n$$\n\\text{Arc length} = \\int_{0}^{s} \\sqrt{\\left( \\frac{dx}{dt} \\right)^2 + \\left( \\frac{dy}{dt} \\right)^2} \\, dt\n$$\n\n### **Solution Steps**\n\n1. **Define the Path Functions**: Create functions for $x(t)$ and $y(t)$ to represent the parametric path.\n2. **Calculate Derivatives**: Calculate $\\frac{dx}{dt}$ and $\\frac{dy}{dt}$, representing the rates of change of $x$ and $y$ with respect to $t$.\n3. **Define the Integrand**: Use the derivatives to compute $\\sqrt{\\left( \\frac{dx}{dt} \\right)^2 + \\left( \\frac{dy}{dt} \\right)^2}$, which represents the instantaneous speed along the path.\n4. **Integrate the Speed**: Integrate this instantaneous speed from $t = 0$ to $t = s$ to obtain the total arc length (distance traveled along the curve).\n\n### **Solution Code**\n\nThe Python code below implements the above steps to calculate the arc length from $t = 0$ to a specified $t = s$ using numerical integration:\n\n::: {#14a0ea1a .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.integrate import quad\n\n# Define the functions for x(t) and y(t)\ndef x(t):\n    return 0.5 + 0.3 * t + 3.9 * t**2 - 4.7 * t**3\n\ndef y(t):\n    return 1.5 + 0.3 * t + 0.9 * t**2 - 2.7 * t**3\n\n# Define the derivatives of x(t) and y(t)\ndef dx_dt(t):\n    return 0.3 + 2 * 3.9 * t - 3 * 4.7 * t**2\n\ndef dy_dt(t):\n    return 0.3 + 2 * 0.9 * t - 3 * 2.7 * t**2\n\n# Define the integrand for the arc length\ndef integrand(t):\n    return np.sqrt(dx_dt(t)**2 + dy_dt(t)**2)\n\n# Function to compute the arc length from t=0 to t=s\ndef compute_arc_length(s):\n    arc_length, _ = quad(integrand, 0, s)\n    return arc_length\n```\n:::\n\n\n### **Explanation of Solution Components**\n\n1. **Path Functions $x(t)$ and $y(t)$**: The functions $x(t)$ and $y(t)$ define the parametric equations for the path.\n2. **Derivatives $dx/dt$ and $dy/dt$**: The functions `dx_dt` and `dy_dt` compute the derivatives of $x(t)$ and $y(t)$ with respect to $t$, representing the rate of change at each point along the path.\n3. **Arc Length Integrand**: The `integrand` function calculates the instantaneous speed along the path by combining $dx/dt$ and $dy/dt$ using the Pythagorean theorem.\n4. **Integration**: The `compute_arc_length` function uses numerical integration to compute the total arc length from $t = 0$ to $t = s$, giving the distance traveled along the curve.\n\n### **Result and Observations**\n\nThis function successfully computes the arc length for any specified $s$, providing an accurate measure of the total distance traveled along the path up to that point. By integrating the instantaneous speed, this approach accounts for the curvature and direction changes of the path.\n\n# **PROBLEM 02**\n\n---\n\n### **Problem Statement**\n\nWrite a program that, for any input $0 \\leq s \\leq 1$, finds the parameter $t^*(s)$ that is $s$ of the way along the path. In other words, the arc length from $t = 0$ to $t = t^*(s)$ divided by the arc length from $t = 0$ to $t = 1$ should be equal to $s$. Use the Bisection Method to locate the point $t^*(s)$ to three correct decimal places.\n\n**Key Questions**:\n\n- What function is being set to zero?\n- What bracketing interval should be used to start the Bisection Method?\n\n### **Objective and Approach**\n\nThe objective is to determine the parameter $t^*(s)$ such that the arc length from $t = 0$ to $t = t^*(s)$ represents a fraction $s$ (where $0 \\leq s \\leq 1$) of the total path length.\n\nTo accomplish this:\n\n1. **Condition Definition**: Define the condition that the arc length from $t = 0$ to $t = t^*(s)$ divided by the total arc length (from $t = 0$ to $t = 1$) should be equal to $s$:\n\n   $$\n   \\frac{\\int_{0}^{t^*(s)} \\sqrt{\\left( \\frac{dx}{dt} \\right)^2 + \\left( \\frac{dy}{dt} \\right)^2} \\, dt}{\\int_{0}^{1} \\sqrt{\\left( \\frac{dx}{dt} \\right)^2 + \\left( \\frac{dy}{dt} \\right)^2} \\, dt} = s\n   $$\n\n2. **Objective Function**: Rewrite this condition as $f(t) = 0$, where\n\n   $$\n   f(t) = \\frac{\\text{Arc length from } t = 0 \\text{ to } t^*(s)}{\\text{Total arc length}} - s\n   $$\n\n3. **Bisection Method**: Use the Bisection Method to find $t$ such that $f(t) = 0$, starting with an initial interval of \\([0, 1]\\) and achieving a precision of three decimal places.\n\n### **Solution Code**\n\nThe Python code below implements the above approach using the Bisection Method to locate $t^*(s)$ for any input $s$:\n\n::: {#bd383048 .cell execution_count=3}\n``` {.python .cell-code}\n# Total arc length from t=0 to t=1\ntotal_arc_length = compute_arc_length(1)\n\n# Objective function to solve for t^*(s)\ndef f(t, s):\n    return compute_arc_length(t) / total_arc_length - s\n\n# Bisection method to find t^*(s)\ndef find_t_star(s, tol=1e-3):\n    a, b = 0, 1\n    while (b - a) / 2 > tol:\n        midpoint = (a + b) / 2\n        if f(midpoint, s) == 0:\n            return midpoint\n        elif f(a, s) * f(midpoint, s) < 0:\n            b = midpoint\n        else:\n            a = midpoint\n    return (a + b) / 2\n\n# Example usage\ns = 0.5  # Example value for s (e.g., halfway along the path)\nt_star = find_t_star(s)\n```\n:::\n\n\n### **Explanation of Solution Components**\n\n1. **Objective Function $f(t, s)$**: This function calculates the difference between the actual fraction of the arc length from $t = 0$ to $t$ and the target fraction $s$. The goal is to find $t$ where this difference is zero, meaning the arc length up to $t$ matches the desired fraction $s$.\n2. **Bisection Method**: The `find_t_star` function implements the Bisection Method to iteratively refine the interval until $f(t) = 0$ within a specified tolerance, ensuring $t^*(s)$ is accurate to three decimal places.\n\n### **Result and Observations**\n\nThis solution accurately finds $t^*(s)$ for any input $s$, ensuring that the corresponding point on the path represents exactly $s$ of the total arc length. By using the Bisection Method, this approach achieves high precision even for paths with complex curves.\n\n# **PROBLEM 03**\n\n## **Path Equipartitioning by Arc Length**\n\n### **Problem Statement**\n\nEquipartition the path of Figure 5.6 into $n$ subpaths of equal length, for $n = 4$ and $n = 20$. Plot analogues of Figure 5.6, showing the equipartitions.\n\n::: {#967d972b .cell execution_count=4}\n\n::: {.cell-output .cell-output-display}\n![](rc05_files/figure-html/cell-5-output-1.png){width=456 height=450}\n:::\n:::\n\n\n### **Objective and Approach**\n\nThe objective is to partition the path, defined by parametric equations $x(t)$ and $y(t)$, into segments of equal arc length for a specified $n$. This method is valuable in fields requiring consistent movement along a path, such as animation or robotics.\n\nThe approach includes the following steps:\n\n1. **Calculate Total Arc Length**: Compute the total arc length from $t = 0$ to $t = 1$ using numerical integration, enabling calculation of the length of each segment.\n\n   $$\n   \\text{Segment length} = \\frac{\\text{Total arc length}}{n}\n   $$\n\n2. **Locate Partition Points Using the Bisection Method**: For each segment $i$, use the Bisection Method to locate the parameter $t_i$ so that the arc length from $t = 0$ to $t = t_i$ equals $i \\times \\text{Segment length}$. This ensures equal arc lengths for each segment.\n\n3. **Plot the Equipartitioned Path**: Calculate $x(t_i)$ and $y(t_i)$ at each partition point and plot for both $n = 4$ and $n = 20$, visualizing uniform segmentation.\n\n### **Solution Code**\n\n::: {#p3 .cell execution_count=5}\n``` {.python .cell-code}\n# Bisection method to find t for a target arc length fraction\ndef bisection_find_t(target_length, tol=1e-8):\n    a, b = 0, 1\n    while (b - a) / 2 > tol:\n        midpoint = (a + b) / 2\n        if compute_arc_length(midpoint) == target_length:\n            return midpoint\n        elif compute_arc_length(midpoint) < target_length:\n            a = midpoint\n        else:\n            b = midpoint\n    return (a + b) / 2\n\n# Equipartition function\ndef equipartition(n):\n    partition_points = [0]\n    total_length = compute_arc_length(1)\n    segment_length = total_length / n\n    for i in range(1, n):\n        target_length = i * segment_length\n        t_i = bisection_find_t(target_length)\n        partition_points.append(t_i)\n    partition_points.append(1)\n    return partition_points\n\n# Plot function for equipartitioned curve\ndef plot_styled_curve(n):\n    plt.figure(figsize=(8, 8), facecolor='white')\n\n    t_vals = np.linspace(0, 1, 500)\n    x_vals = x(t_vals)\n    y_vals = y(t_vals)\n\n    key_points_t = equipartition(n)\n    key_points_x = [x(t) for t in key_points_t]\n    key_points_y = [y(t) for t in key_points_t]\n\n    # Plot the curve with enhanced styling\n    plt.plot(x_vals, y_vals, color=\"#2196F3\", linewidth=2.5, zorder=3)\n    plt.scatter(key_points_x, key_points_y, color=\"#1565C0\", s=40, zorder=4)\n\n    # Add grid with softer appearance\n    plt.grid(True, linestyle='-', alpha=0.2, color='gray')\n    plt.xticks(np.arange(-1, 1.5, 0.5))\n    plt.yticks(np.arange(0, 2.5, 0.5))\n\n\n    # Enhanced axis lines\n    ax = plt.gca()\n    ax.set_xticklabels(['' if x == 0 else str(x) for x in ax.get_xticks()])\n    ax.set_yticklabels(['' if y == 0 else str(y) for y in ax.get_yticks()])\n\n    ax.spines['left'].set_position('zero')\n    ax.spines['bottom'].set_position('zero')\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.spines['left'].set_linewidth(1.5)\n    ax.spines['bottom'].set_linewidth(1.5)\n\n    # Enhance tick appearance\n    plt.tick_params(axis='both', which='major', length=6, width=1, colors='black', direction='out')\n    plt.tick_params(axis='both', which='minor', length=3, width=1, colors='black', direction='out')\n\n    # Label positioning and styling\n    ax.set_ylabel('y', rotation=0, labelpad=15, y=1.02, fontsize=12)\n    ax.set_xlabel('x', x=1.02, fontsize=12)\n\n    plt.xlim(-1.5, 1.5)\n    plt.ylim(-0.5, 2)\n    plt.gca().set_aspect('equal')\n\n    plt.show()\n```\n:::\n\n\n#### Equipartitioned Curve with $n = 4$\n\n::: {#6a590ef5 .cell execution_count=6}\n\n::: {.cell-output .cell-output-display}\n![](rc05_files/figure-html/cell-7-output-1.png){width=627 height=533}\n:::\n:::\n\n\n#### Equipartitioned Curve with $n = 20$\n\n::: {#32cdcc76 .cell execution_count=7}\n\n::: {.cell-output .cell-output-display}\n![](rc05_files/figure-html/cell-8-output-1.png){width=627 height=533}\n:::\n:::\n\n\n### **Explanation of Solution Components**\n\n1. **Arc Length Calculation**: The function `compute_arc_length(s)` uses numerical integration to compute the arc length from $t = 0$ to a given $t = s$.\n\n2. **Bisection Method for Partitioning**: `bisection_find_t(target_length)` finds the parameter $t$ corresponding to a specific arc length, ensuring accurate partition points.\n\n3. **Equipartition Function**: `equipartition(n)` calculates $t$-values for partitioning the path into $n$ equal arc-length segments.\n\n4. **Visualization**: `plot_styled_curve(n)` generates a plot showing the path with points marking each partition.\n\n### **Results and Observations**\n\nThe plots for $n = 4$ and $n = 20$ illustrate the uniform segmentation of the path into equal-length segments, confirming the effectiveness of the equipartitioning process. This approach achieves constant distances along the path, despite non-uniform parameter spacing.\n\n### **Conclusion**\n\nThe solution effectively partitions the path into equal-length segments using numerical integration and the Bisection Method. This method can be further enhanced by employing Newton’s Method for faster convergence or adapting it to three-dimensional paths.\n\n# **PROBLEM 04**\n\n## **Path Equipartitioning Using Newton’s Method**\n\n### **Problem Statement**\n\nReplace the Bisection Method in Step 2 with Newton’s Method, and repeat Steps 2 and 3. What is the derivative needed? What is a good choice for the initial guess? Is computation time decreased by this replacement?\n\n### **Objective and Approach**\n\n1. **Objective**: Use Newton’s Method to locate each partition point $t_i$ along the path, ensuring equal arc-length segments for a specified number of partitions $n$. Newton’s Method is expected to offer faster convergence than the Bisection Method, especially when starting with a good initial guess.\n\n2. **Required Derivative**: Newton’s Method requires the derivative of the arc length function with respect to $t$, which is simply the arc length integrand evaluated at $t$:\n\n   $$\n   f'(t) = \\sqrt{\\left( \\frac{dx}{dt} \\right)^2 + \\left( \\frac{dy}{dt} \\right)^2}\n   $$\n\n3. **Initial Guess**: A reasonable initial guess for each $t_i$ is $t_i = \\frac{i}{n}$, which provides a uniformly spaced initial estimate along $t$, aiding the convergence of Newton’s Method.\n\n4. **Performance Comparison**: To evaluate if Newton’s Method reduces computation time, we will measure the time taken by both the Bisection and Newton’s methods to achieve the same accuracy.\n\n#### **Why $t_i = \\frac{i}{n}$ is a Good Initial Guess**\n\n- **Uniform Parameter Distribution**: The parameter $t$ varies between 0 and 1 (or the specified range of $t$), and $\\frac{i}{n}$ provides evenly spaced points within this interval. This ensures that the initial guess is distributed consistently across the parameter space.\n- **Proximity to the True Solution**: For smooth and \"well-behaved\" curves, the true $t_i$ values for equal arc-length segments are often near $\\frac{i}{n}$. This proximity ensures that Newton’s Method starts \"in the ballpark\" of the correct value.\n- **Simplicity and Efficiency**: Computing $\\frac{i}{n}$ is computationally trivial and requires no extra effort. This simplicity makes it a practical choice compared to complex initialization schemes.\n- **Improved Convergence**: Starting close to the actual solution allows Newton’s Method to converge quadratically, reducing the number of iterations needed to achieve the desired accuracy.\n\n### **Solution Code**\n\nThe following Python code implements Newton’s Method to find partition points and compares its performance with the Bisection Method.\n\n::: {#p4 .cell execution_count=8}\n``` {.python .cell-code}\nimport time\n\n# Newton's Method to find t for a target arc length\ndef newton_find_t(target_length, initial_guess, tol=1e-8, max_iter=100):\n    t = initial_guess\n    for _ in range(max_iter):\n        f_t = compute_arc_length(t) - target_length\n        f_prime_t = integrand(t)\n        if abs(f_t) < tol:\n            return t\n        t -= f_t / f_prime_t  # Update t\n    return t\n\n# Compare performance of Bisection and Newton's methods\ndef compare_performance(target_length):\n    start_time_bisection = time.time()\n    bisection_result = bisection_find_t(target_length)\n    bisection_time = time.time() - start_time_bisection\n\n    start_time_newton = time.time()\n    newton_result = newton_find_t(target_length, initial_guess=0.5)\n    newton_time = time.time() - start_time_newton\n\n    print(f\"Bisection Method Result: {bisection_result:.9f} Time: {bisection_time:.9f} seconds\")\n    print(f\"Newton's Method Result: {newton_result:.9f} Time: {newton_time:.9f} seconds\")\n\n# Example target length (e.g., half the arc length)\ntotal_length = compute_arc_length(1)\ncompare_performance(total_length / 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBisection Method Result: 0.800593771 Time: 0.006999016 seconds\nNewton's Method Result: 0.800593767 Time: 0.000000000 seconds\n```\n:::\n:::\n\n\n### **Explanation of Solution Components**\n\n1. **Newton’s Method Implementation**: The `newton_find_t` function applies Newton’s Method to locate the parameter $t$ for a given arc length. It iteratively refines $t$ by calculating $f(t)$ and $f'(t)$, adjusting $t$ based on the result.\n\n2. **Performance Comparison**: The `compare_performance` function compares the time taken by Bisection and Newton’s methods to find the target $t$-value. This illustrates the efficiency difference between the two methods.\n\n### **Results and Observations**\n\n- **Performance Gain**: Newton’s Method generally converges faster than the Bisection Method due to its quadratic convergence rate.\n- **Accuracy**: With an appropriately chosen initial guess, Newton’s Method efficiently reaches an accurate solution within fewer iterations.\n\n### **Conclusion**\n\nNewton’s Method provides a more efficient approach for finding the partition points, particularly when an initial guess is available. This reduction in computation time makes it suitable for tasks requiring high precision and quick convergence, such as real-time applications in path traversal and equipartitioning. Future explorations could involve further optimizations by dynamically refining initial guesses based on prior calculations.\n\n# **PROBLEM 05**\n\n## **Path Animation at Original and Constant Speed**\n\n### **Problem Statement**\n\nUse Python animation commands to demonstrate traveling along the path in two ways:\n\n1. At the original speed, based on parameter $t$ for $0 \\leq t \\leq 1$, which results in non-uniform speed along the path.\n2. At a constant speed using $t^*(s)$ for $0 \\leq s \\leq 1$, where the path is re-parameterized to maintain equal arc-length segments.\n\n### **Objective and Approach**\n\n1. **Objective**: To visualize the difference between non-uniform and constant-speed traversal along a path.\n\n   - **Original Speed**: Animate movement along the path based on evenly spaced $t$-values, resulting in variable speed.\n   - **Constant Speed**: Animate movement along the path with equal arc-length segments by using equipartition points $t^*(s)$.\n\n2. **Approach**:\n   - **Original Speed Animation**: Use uniformly spaced $t$-values from $t = 0$ to $t = 1$ to display the natural parameter-based speed.\n   - **Constant Speed Animation**: Use the previously calculated equipartition points $t^*(s)$ to animate movement along equal arc-length segments, ensuring a uniform speed.\n\n### **Solution Code**\n\nThe following Python code generates both animations, showing the path traversal at original and constant speeds.\n\n```python\nimport matplotlib.animation as animation\n\ndef animate_path():\n    fig = plt.figure(figsize=(16, 8), facecolor='white')\n\n    ax1 = fig.add_subplot(121)\n    ax2 = fig.add_subplot(122)\n\n    # Generate data for original and constant speed\n    t_values_original_speed = np.linspace(0, 1, 25)\n    x_vals_original_speed = x(t_values_original_speed)\n    y_vals_original_speed = y(t_values_original_speed)\n\n    t_values_constant_speed = equipartition(25)\n    x_vals_constant_speed = [x(t) for t in t_values_constant_speed]\n    y_vals_constant_speed = [y(t) for t in t_values_constant_speed]\n\n    # Enhanced styling function for subplots\n    def style_subplot(ax, title):\n        ax.grid(True, linestyle='-', alpha=0.2, color='gray')\n        ax.set_xlim(-1.5, 1.5)\n        ax.set_ylim(-0.5, 2)\n        ax.set_xticks(np.arange(-1, 1.5, 0.5))\n        ax.set_yticks(np.arange(0, 2.5, 0.5))\n        ax.set_aspect('equal')\n        ax.set_xticklabels(['' if x == 0 else str(x) for x in ax.get_xticks()])\n        ax.set_yticklabels(['' if y == 0 else str(y) for y in ax.get_yticks()])\n\n\n        # Enhanced axis lines\n        ax.spines['left'].set_position('zero')\n        ax.spines['bottom'].set_position('zero')\n        ax.spines['right'].set_visible(False)\n        ax.spines['top'].set_visible(False)\n        ax.spines['left'].set_linewidth(1.5)\n        ax.spines['bottom'].set_linewidth(1.5)\n\n        # Enhanced ticks\n        ax.tick_params(axis='both', which='major', length=6, width=1, colors='black', direction='out')\n        ax.tick_params(axis='both', which='minor', length=3, width=1, colors='black', direction='out')\n\n        ax.set_title(title, pad=20, fontsize=12, fontweight='bold')\n\n    # Configure first subplot\n    ax1.plot(x_vals_original_speed, y_vals_original_speed, color=\"#2196F3\", linewidth=2.5, zorder=3)\n    original_point, = ax1.plot([], [], 'o', color=\"#1565C0\", markersize=8, zorder=4)\n    style_subplot(ax1, \"Original Speed\")\n\n    # Configure second subplot\n    ax2.plot(x_vals_constant_speed, y_vals_constant_speed, color=\"#2196F3\", linewidth=2.5, zorder=3)\n    constant_point, = ax2.plot([], [], 'go',  markersize=8, zorder=4)\n    style_subplot(ax2, \"Constant Speed\")\n\n    plt.tight_layout()\n\n    def update_original(fnum):\n        original_point.set_data(x_vals_original_speed[:fnum], y_vals_original_speed[:fnum])\n        return original_point,\n\n    def update_constant(fnum):\n        constant_point.set_data(x_vals_constant_speed[:fnum], y_vals_constant_speed[:fnum])\n        return constant_point,\n\n    num_frames = len(x_vals_original_speed)\n    ani = animation.FuncAnimation(fig, lambda fnum: update_original(fnum) + update_constant(fnum),\n                                frames=num_frames, interval=200, blit=True)\n    ani.save('combined_animation.mp4', writer='ffmpeg')\n```\n\n<div style=\"display: flex; justify-content: center; margin-top: 1rem;\">\n  <video controls autoplay loop muted width=\"800\">\n    <source src=\"combined_animation.mp4\" type=\"video/mp4\">\n    Your browser does not support the video tag.\n  </video>\n</div>\n\n### **Explanation of Solution Components**\n\n1. **Animation Setup**:\n\n   - **Original Speed**: Uses evenly spaced $t$-values from 0 to 1, resulting in non-uniform movement along the path.\n   - **Constant Speed**: Uses equipartition points $t^*(s)$, calculated to ensure each segment has the same arc length, resulting in uniform movement.\n\n2. **Animation Update Functions**: Each animation frame updates the moving point on the respective path for both original and constant speeds.\n\n### **Results and Observations**\n\nThe two animations effectively demonstrate the difference between moving at a variable speed (based on $t$) and moving at a constant speed along equal arc-length segments. By using equipartition points, the constant-speed animation shows smooth, uniform movement, which can be advantageous for applications requiring consistent traversal rates.\n\n# **PROBLEM 06**\n\n## **Experimenting with Equipartitioning on a Custom Path**\n\n### **Problem Statement**\n\nExperiment with equipartitioning a path of your choice. Choose a path defined by parametric equations, partition it into equal arc-length segments, and animate the traversal as demonstrated in Problem 5.\n\n#### **Chosen Equation:**\n\n$$\nx(t) = 0.4 \\sin(3t + \\frac{\\pi}{2}) + 0.5\n$$\n\n$$\ny(t) = 0.3 \\sin(4t) + 0.5\n$$\n\n### **Objective and Approach**\n\n1. **Objective**: To apply equipartitioning to the specified path, dividing it into segments of equal arc length and visualizing the traversal at constant speed.\n2. **Approach**:\n   - **Path Definition**: Define $x(t)$ and $y(t)$ based on the given equations.\n   - **Equipartitioning**: Use numerical integration and Newton's Method to divide the path into equal-length segments.\n   - **Animation**: Animate the traversal of the path at a constant speed along the equal arc-length segments and compare it with traversal at the original, parameter-based speed.\n\n### **Solution Code**\n\nThe Python code below calculates the equipartitioned segments and animates traversal along the path:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom scipy.integrate import quad\n\n# Parameters for the curve\nA = 0.4\na = 3\nf = np.pi / 2\nc = 0.5\nB = 0.3\nb = 4\nD = 0.5\n\n# Maximum value of t for one full loop\nt_max = 2 * np.pi\n\n# Define the functions for x(t) and y(t)\ndef x(t):\n    return A * np.sin(a * t + f) + c\n\ndef y(t):\n    return B * np.sin(b * t) + D\n\n# Derivatives of x(t) and y(t) for arc length calculation\ndef dx_dt(t):\n    return A * a * np.cos(a * t + f)\n\ndef dy_dt(t):\n    return B * b * np.cos(b * t)\n\n# Integrand for arc length calculation\ndef integrand(t):\n    return np.sqrt(dx_dt(t)**2 + dy_dt(t)**2)\n\n# Compute arc length using numerical integration\ndef compute_arc_length(s):\n    arc_length, _ = quad(integrand, 0, s)\n    return arc_length\n\n# Equipartition function to divide path into equal arc-length segments\ndef equipartition(n):\n    total_length = compute_arc_length(2 * np.pi)\n    segment_length = total_length / n\n    partition_points = [0]\n    for i in range(1, n):\n        target_length = i * segment_length\n        partition_points.append(find_t_for_length(target_length, partition_points[-1]))\n    partition_points.append(2 * np.pi)\n    return partition_points\n\n# Find parameter t for a given arc length using Newton's Method\ndef find_t_for_length(target_length, initial_guess=0, tol=1e-8, max_iter=100):\n    t = initial_guess\n    for _ in range(max_iter):\n        f_t = compute_arc_length(t) - target_length\n        f_prime_t = integrand(t)\n        if abs(f_t) < tol:\n            return t\n        t -= f_t / f_prime_t\n        t = max(0, min(2 * np.pi, t))\n    return t\n\n\n# Data for animations\nn_points = 200\nt_values_original = np.linspace(0, 2 * np.pi, n_points)\nx_original = x(t_values_original)\ny_original = y(t_values_original)\n\nt_values_constant = equipartition(n_points)\nx_constant = [x(t) for t in t_values_constant]\ny_constant = [y(t) for t in t_values_constant]\n\n# Set up the figure for side-by-side animation\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))\n\n# Original speed plot\nax1.plot(x_original, y_original, color=\"#2196F3\", linewidth=2)\npoint1, = ax1.plot([], [], 'o', color=\"#1565C0\")\nax1.set_title(\"Original Speed\")\nax1.set_xlim(0, 1)\nax1.set_ylim(0, 1)\nax1.set_aspect('equal')\nax1.grid(True, linestyle='-', alpha=0.2, color='gray')\n\n# Constant speed plot\nax2.plot(x_constant, y_constant, color=\"#2196F3\", linewidth=2)\npoint2, = ax2.plot([], [], 'go')\nax2.set_title(\"Constant Speed\")\nax2.set_xlim(0, 1)\nax2.set_ylim(0, 1)\nax2.set_aspect('equal')\nax2.grid(True, linestyle='-', alpha=0.2, color='gray')\n\n# Update functions for each animation\ndef update_original(frame):\n    point1.set_data(x_original[:frame], y_original[:frame])\n    return point1,\n\ndef update_constant(frame):\n    point2.set_data(x_constant[:frame], y_constant[:frame])\n    return point2,\n\n# Combine animations into one\nnum_frames = len(x_original)\nani = animation.FuncAnimation(\n    fig,\n    lambda frame: update_original(frame) + update_constant(frame),\n    frames=num_frames,\n    interval=100,\n    blit=True\n)\n\n# Save animation as MP4\nani.save(\"custom_path_animation.mp4\", writer=\"ffmpeg\")\n```\n\n<div style=\"display: flex; justify-content: center; margin-top: 1rem;\">\n  <video controls autoplay loop muted width=\"800\">\n    <source src=\"custom_path_animation.mp4\" type=\"video/mp4\">\n    Your browser does not support the video tag.\n  </video>\n</div>\n\n### **Explanation of Solution Components**\n\n1. **Path Definition**: The parametric equations for $x(t) = 0.4 \\sin(3t + \\frac{\\pi}{2}) + 0.5$ and $y(t) = 0.3 \\sin(4t) + 0.5$ define a periodic curve with sinusoidal behavior, creating a visually interesting pattern with symmetric, tight curves.\n2. **Arc Length Calculation**: The function `compute_arc_length` integrates the instantaneous speed along the curve (using derivatives $dx/dt$ and $dy/dt$) over the interval [0, s] to determine the total distance traveled up to a given $s$.\n3. **Equipartitioning**: The `equipartition` function divides the path into $n$ segments of equal arc length by calculating the target length of each segment and using Newton's Method to determine $t$ values corresponding to each target segment length. This ensures the segments are evenly spaced along the curve.\n4. **Animation**: The `animate_path` function generates side-by-side animations of path traversal at original speed (based on parameter $t$) and constant speed (based on equal arc-length segments).\n\n### **Results and Observations**\n\nIn the animation:\n\n- **Original Speed**: The left animation shows traversal based on equally spaced $t$ values, resulting in variable speed along the curve. The point moves faster along straighter sections and slows down significantly in tighter curves.\n- **Constant Speed**: The right animation demonstrates traversal at a constant speed along equal arc-length segments. This movement is smoother and consistent, highlighting how equipartitioning ensures a steady traversal rate even along complex paths.\n\n### **Conclusion**\n\nThis exercise illustrates the benefits of equipartitioning a path into equal arc-length segments for applications that require consistent speed. By reparameterizing the curve to maintain constant speed, we can avoid the variable movement speed that results from a simple, evenly spaced parameter $t$. This method has potential applications in animation, robotics, and automated manufacturing, where uniform movement along a path with varying curvature is essential.\n\n# **CODE**\n\nThe code above can be organized into a `ParametricCurve` class to improve structure and follow best practices. This class combines all the key methods, such as arc length computation, root-finding, and equipartitioning, into a clear and reusable design.\n\n```python\nclass ParametricCurve:\n    def __init__(self, x_func, y_func, dx_dt_func, dy_dt_func, t_min=0, t_max=1):\n        self.x = x_func\n        self.y = y_func\n        self.dx_dt = dx_dt_func\n        self.dy_dt = dy_dt_func\n        self.t_min = t_min\n        self.t_max = t_max\n\n    def integrand(self, t):\n        return np.sqrt(self.dx_dt(t)**2 + self.dy_dt(t)**2)\n\n    @lru_cache(maxsize=None)\n    def compute_arc_length(self, s):\n        arc_length, _ = quad(self.integrand, self.t_min, s)\n        return arc_length\n\n    def total_length(self):\n        return self.compute_arc_length(self.t_max)\n\n    def newton_find_t(self, target_length, initial_guess=None, tol=1e-8, max_iter=100):\n        if initial_guess is None:\n            initial_guess = (self.t_min + self.t_max) / 2\n        t = initial_guess\n        for _ in range(max_iter):\n            f_t = self.compute_arc_length(t) - target_length\n            f_prime_t = self.integrand(t)\n            if abs(f_t) < tol:\n                return t\n            if f_prime_t == 0:\n                raise ZeroDivisionError(\"Derivative zero encountered in Newton's method.\")\n            t -= f_t / f_prime_t\n            t = max(self.t_min, min(self.t_max, t))\n        raise RuntimeError(\"Newton's method did not converge.\")\n\n    def bisection_find_t(self, target_length, a=None, b=None, tol=1e-8, max_iter=100):\n        if a is None:\n            a = self.t_min\n        if b is None:\n            b = self.t_max\n        fa = self.compute_arc_length(a) - target_length\n        fb = self.compute_arc_length(b) - target_length\n        if fa * fb > 0:\n            raise ValueError(\"Bisection method fails: function has same signs at interval endpoints.\")\n        for _ in range(max_iter):\n            t = (a + b) / 2\n            f_t = self.compute_arc_length(t) - target_length\n            if abs(f_t) < tol:\n                return t\n            if fa * f_t < 0:\n                b = t\n                fb = f_t\n            else:\n                a = t\n                fa = f_t\n        return t\n\n    def equipartition(self, n, method='newton'):\n        total_length = self.total_length()\n        segment_length = total_length / n\n        partition_points = [self.t_min]\n        for i in range(1, n):\n            target_length = i * segment_length\n            initial_guess = partition_points[-1]\n            if method == 'newton':\n                t_i = self.newton_find_t(target_length, initial_guess)\n            elif method == 'bisection':\n                t_i = self.bisection_find_t(target_length, a=initial_guess)\n            else:\n                raise ValueError(\"Method must be 'newton' or 'bisection'.\")\n            partition_points.append(t_i)\n        partition_points.append(self.t_max)\n        return partition_points\n```\n\n### **Usage Example**\n\nTo use the `ParametricCurve` class for problem 1-6:\n\n```python\n# Define the first curve\ndef x1(t):\n    return 0.5 + 0.3 * t + 3.9 * t**2 - 4.7 * t**3\n\ndef y1(t):\n    return 1.5 + 0.3 * t + 0.9 * t**2 - 2.7 * t**3\n\ndef dx1_dt(t):\n    return 0.3 + 2 * 3.9 * t - 3 * 4.7 * t**2\n\ndef dy1_dt(t):\n    return 0.3 + 2 * 0.9 * t - 3 * 2.7 * t**2\n\n# Create an instance of ParametricCurve for the first curve\ncurve1 = ParametricCurve(x1, y1, dx1_dt, dy1_dt, t_min=0, t_max=1)\n\n# Define the second curve\nA = 0.4\na = 3\nf = np.pi / 2\nc = 0.5\nB = 0.3\nb = 4\nD = 0.5\nt_max2 = 2 * np.pi\n\ndef x2(t):\n    return A * np.sin(a * t + f) + c\n\ndef y2(t):\n    return B * np.sin(b * t) + D\n\ndef dx2_dt(t):\n    return A * a * np.cos(a * t + f)\n\ndef dy2_dt(t):\n    return B * b * np.cos(b * t)\n\n# Create an instance of ParametricCurve for the second curve\ncurve2 = ParametricCurve(x2, y2, dx2_dt, dy2_dt, t_min=0, t_max=t_max2)\n\ndef style_plot(ax, x_limits, y_limits, adjust_tick_labels=True):\n\n    ax.grid(True, linestyle='-', alpha=0.2, color='gray')\n    ax.set_xticks(np.arange(x_limits[0], x_limits[1] + 0.5, 0.5))\n    ax.set_yticks(np.arange(y_limits[0], y_limits[1] + 0.5, 0.5))\n\n    if adjust_tick_labels:\n        ax.set_xticklabels(['' if x == 0 else f\"{x:.1f}\" for x in ax.get_xticks()])\n        ax.set_yticklabels(['' if y == 0 else f\"{y:.1f}\" for y in ax.get_yticks()])\n\n    ax.spines['left'].set_position('zero')\n    ax.spines['bottom'].set_position('zero')\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.spines['left'].set_linewidth(1.5)\n    ax.spines['bottom'].set_linewidth(1.5)\n\n    ax.tick_params(axis='both', which='major', length=6, width=1, colors='black', direction='out')\n    ax.tick_params(axis='both', which='minor', length=3, width=1, colors='black', direction='out')\n\n    ax.set_xlim(x_limits)\n    ax.set_ylim(y_limits)\n    ax.set_aspect('equal')\n\ndef plot_curve(curve, n_points=500, n_equipartition=None, title='Parametric Curve', x_limits=(-1.5, 1.5), y_limits=(-0.5, 2)):\n    t_vals = np.linspace(curve.t_min, curve.t_max, n_points)\n    x_vals = curve.x(t_vals)\n    y_vals = curve.y(t_vals)\n\n    plt.figure(figsize=(8, 8), facecolor='white')\n    ax = plt.gca()\n\n    plt.plot(x_vals, y_vals, color=\"#2196F3\", linewidth=2.5, zorder=3)\n\n    # Plot equipartition points if requested\n    if n_equipartition is not None:\n        partition_points = curve.equipartition(n_equipartition)\n        x_points = [curve.x(t) for t in partition_points]\n        y_points = [curve.y(t) for t in partition_points]\n        plt.scatter(x_points, y_points, color=\"#1565C0\", s=40, zorder=4)\n\n    style_plot(ax, x_limits, y_limits)\n    plt.title(title, fontsize=14, fontweight='bold', pad=20)\n    plt.show()\n\ndef animate_curve(curve, n_frames=100, filename='animation.mp4', x_limits=(-1.5, 1.5), y_limits=(-0.5, 2), xticks=None, yticks=None):\n    # Original speed parameterization\n    t_values_original = np.linspace(curve.t_min, curve.t_max, n_frames)\n    x_original = curve.x(t_values_original)\n    y_original = curve.y(t_values_original)\n\n    # Constant speed parameterization\n    t_values_constant = curve.equipartition(n_frames)\n    x_constant = [curve.x(t) for t in t_values_constant]\n    y_constant = [curve.y(t) for t in t_values_constant]\n\n    # Set up the figure\n    fig = plt.figure(figsize=(16, 8), facecolor='white')\n    ax1 = fig.add_subplot(121)\n    ax2 = fig.add_subplot(122)\n\n    # Plot the curves\n    ax1.plot(x_original, y_original, color=\"#2196F3\", linewidth=2.5, zorder=3)\n    ax2.plot(x_constant, y_constant, color=\"#2196F3\", linewidth=2.5, zorder=3)\n\n    # Initialize the points\n    point1, = ax1.plot([], [], 'o', color=\"#1565C0\", markersize=8, zorder=4)\n    point2, = ax2.plot([], [], 'go', markersize=8, zorder=4)\n\n    style_plot(ax1, x_limits, y_limits, adjust_tick_labels=True)\n    style_plot(ax2, x_limits, y_limits, adjust_tick_labels=True)\n\n    if xticks is not None:\n        ax1.set_xticks(xticks)\n        ax2.set_xticks(xticks)\n        ax1.set_xticklabels([f\"{x:.1f}\" for x in xticks])\n        ax2.set_xticklabels([f\"{x:.1f}\" for x in xticks])\n    if yticks is not None:\n        ax1.set_yticks(yticks)\n        ax2.set_yticks(yticks)\n        ax1.set_yticklabels([f\"{y:.1f}\" for y in yticks])\n        ax2.set_yticklabels([f\"{y:.1f}\" for y in yticks])\n\n    ax1.set_title(\"Original Speed\", fontsize=12, fontweight='bold', pad=15)\n    ax2.set_title(\"Constant Speed\", fontsize=12, fontweight='bold', pad=15)\n    plt.tight_layout()\n\n    # Update functions\n    def update(frame):\n        # Update original speed point\n        point1.set_data(x_original[:frame], y_original[:frame])\n        # Update constant speed point\n        point2.set_data(x_constant[:frame], y_constant[:frame])\n        return point1, point2\n\n    ani = animation.FuncAnimation(fig, update, frames=n_frames, interval=200, blit=True)\n    # Save the animation\n    ani.save(filename, writer='ffmpeg')\n    plt.show()\n\ndef compare_performance(curve, target_length):\n    start_time_bisection = time.time()\n    bisection_result = curve.bisection_find_t(target_length)\n    bisection_time = time.time() - start_time_bisection\n\n    start_time_newton = time.time()\n    newton_result = curve.newton_find_t(target_length)\n    newton_time = time.time() - start_time_newton\n\n    print(f\"Bisection Method Result: {bisection_result:.9f} Time: {bisection_time:.9f} seconds\")\n    print(f\"Newton's Method Result: {newton_result:.9f} Time: {newton_time:.9f} seconds\")\n\n# Compute total arc length of the first curve\ntotal_length1 = curve1.total_length()\nprint(f\"Arc Length from t=0 to t=1: {total_length1:.6f}\")\n\n# Compare performance of root-finding methods on the first curve\nprint(\"\\nComparing Performance of Bisection and Newton's Methods:\")\ncompare_performance(curve1, total_length1 / 2)\n\n# Plot the first curve with equipartition points (n=4 and n=20)\nplot_curve(curve1, n_points=500, n_equipartition=4, title='Curve with 4 Equipartition Points')\nplot_curve(curve1, n_points=500, n_equipartition=20, title='Curve with 20 Equipartition Points')\n\n# Animate the first curve\nanimate_curve(curve1, n_frames=25, filename='combined_animation.mp4')\n\n# Adjusted ticks\nxticks = np.arange(0, 1.1, 0.2)\nyticks = np.arange(0, 1.1, 0.2)\n\n# Animate the second curve\nanimate_curve(curve2, n_frames=200, filename='custom_path_animation.mp4', x_limits=(0, 1), y_limits=(0, 1), xticks=xticks, yticks=yticks)\n\n```\n\n",
    "supporting": [
      "rc05_files"
    ],
    "filters": [],
    "includes": {}
  }
}