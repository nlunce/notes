{
  "hash": "a7ff2615e0a3c36a547252bafda6b720",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'REALITY CHECK 04 - CODE'\nauthor: 'Nathan Lunceford'\nformat:\n  html:\n    self-contained: true\n    page-layout: full\n    toc: true\n    toc-depth: 3\n    toc-location: right\n    number-sections: false\n    html-math-method: katex\n    embed-resources: true\n    code-fold: true\n    code-summary: 'Show Code'\n    code-overflow: wrap\n    code-copy: hover\n    code-tools:\n      source: false\n      toggle: true\n      caption: See code\nengine: jupyter\npreview:\n  port: 3000\n  browser: true\n  watch-inputs: true\n  navigate: true\n---\n\n\n```python\n#Import Libraries\nimport numpy as np\nfrom scipy.optimize import fsolve\nimport sympy as sp\n\n# -----------------------------------------------------\n# PROBLEM 1: Numerical Root-Finding for GPS Positioning\n# -----------------------------------------------------\n\n# Given constants and satellite data\nc = 299792.458  # Speed of light in km/s\nA = [15600, 18760, 17610, 19170]  # Satellite x-coordinates in km\nB = [7540, 2750, 14630, 610]      # Satellite y-coordinates in km\nC = [20140, 18610, 13480, 18390]  # Satellite z-coordinates in km\nt = [0.07074, 0.07220, 0.07690, 0.07242]  # Signal travel times in seconds\n\n# Function to define the residuals for the nonlinear system\ndef residuals(vars):\n    \"\"\"\n    Residual function for GPS equations:\n    sqrt((x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2) - c * (t_i - d)\n    \"\"\"\n    x, y, z, d = vars  # Unpack the unknowns\n    res = []\n    for i in range(4):  # Loop through the 4 satellites\n        dist = np.sqrt((x - A[i])**2 + (y - B[i])**2 + (z - C[i])**2)\n        res.append(dist - c * (t[i] - d))  # Append each residual\n    return res\n\n# Initial guess for (x, y, z, d)\ninitial_guess = [0, 0, 6370.0, 0]  # Receiver near Earth's surface and d = 0\n\n# Solve the nonlinear system using fsolve\nsol = fsolve(residuals, initial_guess)\n\n# Print the solution for (x, y, z, d)\nprint(\"----- PROBLEM 1: Numerical Solution -----\")\nprint(f\"x = {sol[0]:.6f} km\")\nprint(f\"y = {sol[1]:.6f} km\")\nprint(f\"z = {sol[2]:.6f} km\")\nprint(f\"d = {sol[3]:.6e} seconds\")\nprint(\"-----------------------------------------\\n\")\n\n# ------------------------------------------------------------\n# PROBLEM 2: Determinant-Based Analytical Approach for GPS\n# ------------------------------------------------------------\n\n# Define symbolic variables\nx, y, z, d = sp.symbols('x y z d', real=True)\n\n# Formulate the nonlinear equations\neqs = []\nfor i in range(4):\n    eq = (x - A[i])**2 + (y - B[i])**2 + (z - C[i])**2 - (c * (t[i] - d))**2\n    eqs.append(eq)\n\n# Linearize the system\n# Subtract eqs[1], eqs[2], and eqs[3] from eqs[0] to eliminate x^2, y^2, z^2 terms\nlin_eqs = [sp.simplify(eqs[0] - eqs[i]) for i in range(1, 4)]\n\n# Extract the coefficients of the linear equations\nA_matrix, b_vector = sp.linear_eq_to_matrix(lin_eqs, [x, y, z, d])\n\n# Split the coefficient matrix into components:\nA_xyz = A_matrix[:, :3]  # Coefficients of x, y, z\nA_d = A_matrix[:, 3]     # Coefficient of d\n\n# Solve for x, y, z in terms of d\nxyz_solution = A_xyz.LUsolve(b_vector - A_d * d)\n\n# Simplify solutions for x, y, z as functions of d\nx_d = sp.simplify(xyz_solution[0])\ny_d = sp.simplify(xyz_solution[1])\nz_d = sp.simplify(xyz_solution[2])\n\n# Substitute x(d), y(d), z(d) into the first original equation\nquadratic_eq_d = sp.simplify(eqs[0].subs({x: x_d, y: y_d, z: z_d}))\n\n# Solve the resulting quadratic equation for d\ncoeffs_d = sp.Poly(quadratic_eq_d, d).all_coeffs()\nd_solutions = sp.solve(quadratic_eq_d, d)\n\n# Select the physically meaningful solution for d (real and close to zero)\nd_final = None\nfor candidate in d_solutions:\n    if candidate.is_real:\n        d_final = candidate.evalf()\n        break\n\n# Compute final (x, y, z) by substituting d into x_d, y_d, z_d\nx_final = x_d.subs(d, d_final).evalf()\ny_final = y_d.subs(d, d_final).evalf()\nz_final = z_d.subs(d, d_final).evalf()\n\n# Print the final analytical solution\nprint(\"----- PROBLEM 2: Analytical Solution -----\")\nprint(f\"x = {x_final:.6f} km\")\nprint(f\"y = {y_final:.6f} km\")\nprint(f\"z = {z_final:.6f} km\")\nprint(f\"d = {d_final:.6e} seconds\")\nprint(\"-----------------------------------------\")\n\n# ------------------------------------------------------------\n# PROBLEM 4 & 5: Conditioning Analysis of the GPS Problem\n# ------------------------------------------------------------\n\n# Constants\nc = 299792.458  # Speed of light in km/s\nrho = 26570  # Fixed satellite altitude in km\nreceiver_pos = np.array([0, 0, 6370])  # Receiver fixed at Earth's surface\nd_initial = 0.0001  # Initial clock bias\nperturbation = 1e-8  # Perturbation in seconds\n\n# Function to compute satellite positions in Cartesian coordinates\ndef compute_satellite_positions(phi, theta):\n    A = [rho * np.cos(p) * np.cos(t) for p, t in zip(phi, theta)]\n    B = [rho * np.cos(p) * np.sin(t) for p, t in zip(phi, theta)]\n    C = [rho * np.sin(p) for p in phi]\n    return np.array(A), np.array(B), np.array(C)\n\n# Compute nominal ranges and travel times\ndef compute_nominal_values(A, B, C):\n    R = np.sqrt((A - receiver_pos[0])**2 + (B - receiver_pos[1])**2 + (C - receiver_pos[2])**2)\n    t_nominal = d_initial + R / c\n    return R, t_nominal\n\n# GPS residual function\ndef gps_residuals(vars, t, A, B, C):\n    x, y, z, d = vars\n    residuals = np.sqrt((x - A)**2 + (y - B)**2 + (z - C)**2) - c * (t - d)\n    return residuals\n\n# EMF computation function\ndef compute_emf(t_perturbed, t_nominal, A, B, C):\n    initial_guess = [0, 0, 6370, d_initial]\n    sol_nominal = fsolve(gps_residuals, initial_guess, args=(t_nominal, A, B, C))\n    sol_perturbed = fsolve(gps_residuals, initial_guess, args=(t_perturbed, A, B, C))\n\n    position_error = np.linalg.norm(np.array(sol_perturbed[:3]) - np.array(sol_nominal[:3]))\n    input_error = np.linalg.norm(np.array(t_perturbed) - np.array(t_nominal)) * c\n    return position_error / input_error\n\n# Function to analyze EMF for given satellite configuration\ndef analyze_emf(phi, theta):\n    A, B, C = compute_satellite_positions(phi, theta)\n    _, t_nominal = compute_nominal_values(A, B, C)\n\n    emf_values = []\n    for i in range(4):\n        t_perturbed = t_nominal.copy()\n        t_perturbed[i] += perturbation\n        emf = compute_emf(t_perturbed, t_nominal, A, B, C)\n        emf_values.append(emf)\n\n    return emf_values\n\n# Loose satellite configuration\nphi_loose = [np.pi / 6, np.pi / 4, np.pi / 3, np.pi / 8]\ntheta_loose = [0, np.pi / 2, np.pi, 3 * np.pi / 2]\nemf_loose = analyze_emf(phi_loose, theta_loose)\n\n# Tightly grouped satellite configuration\ndef tightly_grouped_coordinates(phi_base, theta_base, perturb=0.05):\n    np.random.seed(42)  # For reproducibility\n    phi_tight = [phi_base * (1 + np.random.uniform(-perturb, perturb)) for _ in range(4)]\n    theta_tight = [theta_base * (1 + np.random.uniform(-perturb, perturb)) for _ in range(4)]\n    return phi_tight, theta_tight\n\nphi_base, theta_base = np.pi / 4, np.pi / 2\nphi_tight, theta_tight = tightly_grouped_coordinates(phi_base, theta_base)\nemf_tight = analyze_emf(phi_tight, theta_tight)\n\n# Print results\nprint(\"----- PROBLEM 4 & 5: CONDITIONING ANALYSIS COMPARISON -----\")\nprint(\"Loose Satellites:\")\nfor i, emf in enumerate(emf_loose):\n    print(f\"EMF for perturbation in t_{i+1}: {emf:.6f}\")\nprint(f\"Maximum EMF (Loose): {max(emf_loose):.6f}\\n\")\n\nprint(\"Tightly Grouped Satellites:\")\nfor i, emf in enumerate(emf_tight):\n    print(f\"EMF for perturbation in t_{i+1}: {emf:.6f}\")\nprint(f\"Maximum EMF (Tight): {max(emf_tight):.6f}\")\nprint(\"--------------------------------------------\")\n```\n\n",
    "supporting": [
      "rc04-code_files"
    ],
    "filters": [],
    "includes": {}
  }
}