{
  "hash": "dfd44d5edf98f8fd102aafd27c610ad2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Understanding the Error Magnification Factor (EMF)'\nauthor: 'Nathan Lunceford'\nformat:\n  html:\n    self-contained: true\n    page-layout: full\n    toc: true\n    toc-depth: 3\n    toc-location: right\n    number-sections: false\n    html-math-method: katex\n    embed-resources: true\n    code-fold: true\n    code-summary: 'Show Code'\n    code-overflow: wrap\n    code-copy: hover\n    code-tools:\n      source: false\n      toggle: true\n      caption: See code\nengine: jupyter\npreview:\n  port: 3000\n  browser: true\n  watch-inputs: true\n  navigate: true\n---\n\n\n## **Overview**\n\nWhen tackling mathematical problems, especially those involving systems of equations, understanding how errors influence the solutions is paramount. The **Error Magnification Factor (EMF)** is a crucial tool that allows us to analyze the relationship between different types of errors in numerical computations, helping us assess the reliability and stability of our solutions.\n\n## **What is EMF?**\n\nThe **Error Magnification Factor (EMF)** quantifies how an initial error, known as the [**backward error**](./backward-error.html), is amplified when computing a solution, leading to the [**forward error**](./forward-error.html). Think of EMF as a magnifying glass that reveals how minor inaccuracies can escalate into significant discrepancies in the final answer.\n\nMathematically, EMF is defined as:\n\n$$\n\\text{EMF} = \\frac{\\text{Relative Forward Error (RFE)}}{\\text{Relative Backward Error (RBE)}}\n$$\n\n### **Breaking Down the Components**\n\n- [**Relative Forward Error (RFE)**](./relative-forward-error.html): Measures the deviation of the computed solution from the true solution relative to the true solution's magnitude.\n\n  $$\n  \\text{RFE} = \\frac{\\|\\mathbf{x} - \\mathbf{x_a}\\|_\\infty}{\\|\\mathbf{x}\\|_\\infty}\n  $$\n\n- [**Relative Backward Error (RBE)**](./relative-backward-error.html): Quantifies the adjustment needed in the original problem data to make the computed solution exact, relative to the input data's magnitude.\n\n  $$\n  \\text{RBE} = \\frac{\\|\\mathbf{b} - A\\mathbf{x_a}\\|_\\infty}{\\|\\mathbf{b}\\|_\\infty}\n  $$\n\nSubstituting these into the EMF formula:\n\n$$\n\\text{EMF} = \\frac{\\|\\mathbf{x} - \\mathbf{x_a}\\|_\\infty / \\|\\mathbf{x}\\|_\\infty}{\\|\\mathbf{b} - A\\mathbf{x_a}\\|_\\infty / \\|\\mathbf{b}\\|_\\infty} = \\frac{\\|\\mathbf{x} - \\mathbf{x_a}\\|_\\infty}{\\|\\mathbf{x}\\|_\\infty} \\cdot \\frac{\\|\\mathbf{b}\\|_\\infty}{\\|\\mathbf{b} - A\\mathbf{x_a}\\|_\\infty}\n$$\n\nWhere:\n\n- $\\mathbf{x}$: **True Solution**\n- $\\mathbf{x_a}$: **Approximate (Computed) Solution**\n- $\\mathbf{b}$: **Original Input Data**\n- $A$: **Coefficient Matrix** in the system of equations\n\n## **What EMF Represents**\n\nUnderstanding EMF involves dissecting its components and recognizing what they reveal about the system under analysis.\n\n### **1. Forward vs. Backward Error**\n\n- **Backward Error (RBE)**: Think of it as a small mistake in the initial setup of a problem, such as an incorrect measurement or input. It quantifies this initial discrepancy.\n- **Forward Error (RFE)**: Represents how this initial mistake propagates and affects the final solution, showing the deviation from the intended outcome.\n\n**EMF** bridges these two by indicating how much an initial error (RBE) influences the final result (RFE). A higher EMF implies that even minor initial errors can lead to significant deviations in the solution.\n\n### **2. Sensitivity of Solutions**\n\n- **High EMF**: Indicates that the system is **sensitive** or **unstable**. Small errors in the input data can cause large errors in the solution.\n- **Low EMF**: Suggests that the system is **stable**, with errors in input data having minimal impact on the solution.\n\n### **3. Well-Conditioned vs. Ill-Conditioned Systems**\n\n- **Well-Conditioned Systems**: EMF values close to 1. Errors do not get significantly magnified, making the solutions reliable.\n- **Ill-Conditioned Systems**: High EMF values. Small errors can lead to large discrepancies in solutions, rendering them unreliable.\n\n## **Why EMF Matters**\n\nUnderstanding EMF is essential for several reasons:\n\n- **Stability Analysis**: EMF helps determine whether a numerical algorithm will produce reliable results or amplify errors.\n- **Condition Number Connection**: EMF is related to the condition number of matrix $A$, another measure of sensitivity in systems.\n- **Error Propagation**: By analyzing EMF, we can predict how errors in our input data will affect the final solution, enabling us to take corrective measures.\n\n## **A Practical Example**\n\nLet's delve into a concrete example to illustrate how EMF operates in practice.\n\n### **The Problem Setup**\n\nConsider the system of equations:\n\n$$\nA\\mathbf{x} = \\mathbf{b}\n$$\n\nWhere:\n\n- $\\mathbf{x} = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix}$ is the **true solution**.\n- $\\mathbf{x_a} = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$ is the **approximate solution**.\n- $\\mathbf{b} = \\begin{bmatrix} 3 \\\\ 2 \\end{bmatrix}$ is the **input data**.\n- $A = \\begin{bmatrix} 1 & 1 \\\\ 3 & -4 \\end{bmatrix}$ is the **coefficient matrix**.\n\n### **Step 1: Compute the Relative Forward Error (RFE)**\n\nThe RFE measures the deviation of the computed solution from the true solution.\n\n$$\n\\text{RFE} = \\frac{\\|\\mathbf{x} - \\mathbf{x_a}\\|_\\infty}{\\|\\mathbf{x}\\|_\\infty}\n$$\n\n**Calculations:**\n\n1. **Difference Vector**:\n\n   $$\n   \\mathbf{e} = \\mathbf{x} - \\mathbf{x_a} = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} - \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\n   $$\n\n2. **Infinity Norm of $\\mathbf{e}$**:\n\n   $$\n   \\|\\mathbf{e}\\|_\\infty = \\max(|1|, |2|) = 2\n   $$\n\n3. **Infinity Norm of $\\mathbf{x}$**:\n\n   $$\n   \\|\\mathbf{x}\\|_\\infty = \\max(|2|, |1|) = 2\n   $$\n\n4. **RFE**:\n\n   $$\n   \\text{RFE} = \\frac{2}{2} = 1\n   $$\n\n### **Step 2: Compute the Relative Backward Error (RBE)**\n\nThe RBE measures the adjustment needed in the original input data to make the computed solution exact.\n\n$$\n\\text{RBE} = \\frac{\\|\\mathbf{b} - A\\mathbf{x_a}\\|_\\infty}{\\|\\mathbf{b}\\|_\\infty}\n$$\n\n**Calculations:**\n\n1. **Compute $A\\mathbf{x_a}$**:\n\n   $$\n   A\\mathbf{x_a} = \\begin{bmatrix} 1 \\cdot 1 + 1 \\cdot (-1) \\\\ 3 \\cdot 1 + (-4) \\cdot (-1) \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 7 \\end{bmatrix}\n   $$\n\n2. **Residual Vector**:\n\n   $$\n   \\mathbf{r} = \\mathbf{b} - A\\mathbf{x_a} = \\begin{bmatrix} 3 \\\\ 2 \\end{bmatrix} - \\begin{bmatrix} 0 \\\\ 7 \\end{bmatrix} = \\begin{bmatrix} 3 \\\\ -5 \\end{bmatrix}\n   $$\n\n3. **Infinity Norm of $\\mathbf{r}$**:\n\n   $$\n   \\|\\mathbf{r}\\|_\\infty = \\max(|3|, |5|) = 5\n   $$\n\n4. **Infinity Norm of $\\mathbf{b}$**:\n\n   $$\n   \\|\\mathbf{b}\\|_\\infty = \\max(|3|, |2|) = 3\n   $$\n\n5. **RBE**:\n\n   $$\n   \\text{RBE} = \\frac{5}{3} \\approx 1.6667\n   $$\n\n### **Step 3: Compute the EMF**\n\nUsing the RFE and RBE:\n\n$$\n\\text{EMF} = \\frac{\\text{RFE}}{\\text{RBE}} = \\frac{1}{1.6667} \\approx 0.6\n$$\n\n### **Step 4: Interpretation**\n\nAn EMF of **0.6** implies that the backward error is magnified by a factor of 0.6 in the forward error. This indicates that the system is **moderately sensitive** but not highly unstable. While there is some error amplification, it isn't excessively large, suggesting a reasonable level of stability in the solution.\n\n## **Visualization of Errors**\n\nVisual representations can significantly enhance our understanding of EMF. Below is a refined graph that visually illustrates the backward and forward errors in our example, with synchronized domains and ranges for better comparison.\n\n### **Graph of EMF Components**\n\n::: {#cell-emf-components .cell execution_count=1}\n``` {.python .cell-code code-summary=\"Show Code\"}\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.patches import FancyArrowPatch\nfrom matplotlib.patches import Patch\nimport matplotlib.patheffects as pe\n\ndef create_fancy_arrow(start, end, color, width=2, alpha=1.0, zorder=5):\n    \"\"\"Create a fancy arrow without shadow effect for simplicity\"\"\"\n    arrow = FancyArrowPatch(\n        start, end,\n        arrowstyle='->',\n        color=color,\n        linewidth=width,\n        alpha=alpha,\n        zorder=zorder\n    )\n    return arrow\n\nx_true = np.array([2, 1])\nx_a = np.array([1, -1])\nb = np.array([3, 2])\nA = np.array([[1, 1], [3, -4]])\n\nAx_a = A @ x_a\nresidual = b - Ax_a\nforward_error = x_true - x_a\n\nall_vectors = [\n    [0, 0], b, Ax_a, x_true, x_a\n]\nmin_vals = np.min(all_vectors, axis=0) - 1\nmax_vals = np.max(all_vectors, axis=0) + 1\nx_min, x_max = min_vals[0], max_vals[0]\ny_min, y_max = min_vals[1], max_vals[1]\n\nplt.style.use('seaborn-v0_8-whitegrid')\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 8))\n\ncolors = {\n    'b': '#1f77b4',        # blue\n    'Ax_a': '#2ca02c',     # green\n    'residual': '#d62728', # red\n    'x_true': '#000000',   # black\n    'x_a': '#7f7f7f',      # gray\n    'forward': '#ff7f0e'   # orange\n}\n\ninput_vectors = [\n    ((0, 0), b, colors['b'], r'$\\mathbf{b}$'),\n    ((0, 0), Ax_a, colors['Ax_a'], r'$A\\mathbf{x}_a$'),\n    (Ax_a, b, colors['residual'], r'$\\mathbf{r}$')\n]\n\nfor start, end, color, name in input_vectors:\n    ax1.quiver(*start, *(np.array(end) - np.array(start)), color=color, angles='xy', scale_units='xy', scale=1, width=0.01, zorder=5)\n\n    vector = np.array(end) - np.array(start)\n    vector_norm = np.linalg.norm(vector)\n    if vector_norm > 0:\n        direction = vector / vector_norm\n    else:\n        direction = np.array([0, 0])\n\n    perp_direction = np.array([-direction[1], direction[0]])\n    offset = perp_direction * 0.5\n\n    if name == r'$A\\mathbf{x}_a$':\n        offset += np.array([-0.3, 0])\n\n    mid_point = np.array(start) + vector / 2\n    ax1.text(mid_point[0] + offset[0], mid_point[1] + offset[1],\n             name, color=color, fontsize=10, fontweight='bold', zorder=6)\n\nsolution_vectors = [\n    ((0, 0), x_true, colors['x_true'], r'$\\mathbf{x}$'),\n    ((0, 0), x_a, colors['x_a'], r'$\\mathbf{x}_a$'),\n    (x_a, x_true, colors['forward'], r'$\\mathbf{e}$')\n]\n\nfor start, end, color, name in solution_vectors:\n    ax2.quiver(*start, *(np.array(end) - np.array(start)), color=color, angles='xy', scale_units='xy', scale=1, width=0.01, zorder=5)\n\n    vector = np.array(end) - np.array(start)\n    mid_point = np.array(start) + vector / 2\n    offset = np.array([0.3, 0.3])\n\n    if name == r'$\\mathbf{x}_a$':\n        offset += np.array([-0.1, -0.3])\n\n    ax2.text(mid_point[0] + offset[0], mid_point[1] + offset[1],\n             name, color=color, fontsize=10, fontweight='bold', zorder=6)\n\nfor ax, title in zip([ax1, ax2], ['Input Space (Backward Error)', 'Solution Space (Forward Error)']):\n    ax.set_aspect('equal')\n\n    x_padding = (x_max - x_min) * 0.1\n    y_padding = (y_max - y_min) * 0.1\n    ax.set_xlim(x_min - x_padding, x_max + x_padding)\n    ax.set_ylim(y_min - y_padding, y_max + y_padding)\n\n    ax.set_title(title, fontsize=12, pad=15, fontweight='bold')\n\n    ax.set_xlabel('')\n    ax.set_ylabel('')\n\n    ax.grid(color='lightgray', linestyle='--', linewidth=0.7, zorder=0)\n\n    ax.axhline(0, color='black', linewidth=0.8, zorder=1)\n    ax.axvline(0, color='black', linewidth=0.8, zorder=1)\n\nlegend_elements = [\n    Patch(facecolor='none', edgecolor=colors['b'], label=r'$\\mathbf{b}$ (Input)'),\n    Patch(facecolor='none', edgecolor=colors['Ax_a'], label=r'$A\\mathbf{x}_a$ (Computed)'),\n    Patch(facecolor='none', edgecolor=colors['residual'], label=r'$\\mathbf{r}$ (Residual)'),\n    Patch(facecolor='none', edgecolor=colors['x_true'], label=r'$\\mathbf{x}$ (True Solution)'),\n    Patch(facecolor='none', edgecolor=colors['x_a'], label=r'$\\mathbf{x}_a$ (Approximate)'),\n    Patch(facecolor='none', edgecolor=colors['forward'], label=r'$\\mathbf{e}$ (Forward Error)')\n]\n\nfig.legend(handles=legend_elements,\n           loc='upper center',\n           bbox_to_anchor=(0.5, 0.05),\n           ncol=3,\n           fontsize=9)\n\nfig.suptitle('Error Magnification Factor Components', fontsize=14, y=0.98, fontweight='bold')\n\nplt.tight_layout()\nplt.subplots_adjust(top=0.87, bottom=0.15, right=0.95, wspace=-0.4)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](error-magnification-factor_files/figure-html/emf-components-output-1.png){#emf-components width=720 height=783}\n:::\n:::\n\n\n### **Explanation of the Visualization**\n\n- **Left Plot: Input Space (Backward Error)**\n\n  - **$\\mathbf{b}$ (Input)**: Represents the original input data vector.\n  - **$A\\mathbf{x}_a$ (Computed)**: The result of applying the coefficient matrix $A$ to the approximate solution $\\mathbf{x_a}$.\n  - **$\\mathbf{r}$ (Residual)**: The difference between the original input $\\mathbf{b}$ and the computed $A\\mathbf{x}_a$, indicating the backward error.\n\n- **Right Plot: Solution Space (Forward Error)**\n\n  - **$\\mathbf{x}$ (True Solution)**: The actual solution to the system.\n  - **$\\mathbf{x}_a$ (Approximate)**: The computed solution.\n  - **$\\mathbf{e}$ (Forward Error)**: The difference between the true solution and the approximate solution, representing the forward error.\n\nThe arrows visually demonstrate how the backward error in the input space relates to the forward error in the solution space, encapsulating the essence of the EMF.\n\n## **Conclusion**\n\nThe **Error Magnification Factor (EMF)** is a vital concept in numerical analysis, providing insight into how errors propagate through computational processes. By quantifying the relationship between backward and forward errors, EMF helps in assessing the stability and reliability of numerical solutions. Understanding and calculating EMF enables mathematicians and engineers to design more robust algorithms and make informed decisions when interpreting computational results.\n\n",
    "supporting": [
      "error-magnification-factor_files"
    ],
    "filters": [],
    "includes": {}
  }
}