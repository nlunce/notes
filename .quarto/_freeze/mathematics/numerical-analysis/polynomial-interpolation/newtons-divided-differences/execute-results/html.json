{
  "hash": "c7fc7eeb4e56f0817e7f469c77d85dee",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Newton’s Divided Differences'\nauthor: 'Nathan Lunceford'\nformat:\n  html:\n    self-contained: true\n    page-layout: full\n    toc: true\n    toc-depth: 1\n    toc-location: right\n    number-sections: false\n    html-math-method: katex\n    embed-resources: true\n    code-fold: true\n    code-summary: 'Show the code'\n    code-overflow: wrap\n    code-copy: hover\n    code-tools:\n      source: false\n      toggle: true\n      caption: See code\nengine: jupyter\npreview:\n  port: 3000\n  browser: true\n  watch-inputs: true\n  navigate: true\n---\n\n\n**Newton’s Divided Differences** is an efficient method for computing an interpolating polynomial for a given set of data points. This method builds the polynomial iteratively and offers better efficiency for incremental data points compared to [**Lagrange interpolation**](./lagrange-interpolation.html).\n\n## **The Newton Divided Difference Formula**\n\nGiven $n$ data points $(x_1, y_1), (x_2, y_2), ..., (x_n, y_n)$, the **Newton divided difference** interpolating polynomial $P(x)$ can be expressed as:\n\n$$\nP(x) = f[x_1] + f[x_1, x_2](x - x_1) + f[x_1, x_2, x_3](x - x_1)(x - x_2) + \\cdots + f[x_1, x_2, \\ldots, x_n](x - x_1)(x - x_2)\\cdots(x - x_{n-1})\n$$\n\nWhere $f[x_i, x_j, ..., x_k]$ are the **divided differences** and are recursively defined as follows:\n\n$$\nf[x_i] = y_i\n$$\n\n$$\nf[x_i, x_j] = \\frac{f[x_j] - f[x_i]}{x_j - x_i}\n$$\n\n$$\nf[x_i, x_j, x_k] = \\frac{f[x_j, x_k] - f[x_i, x_j]}{x_k - x_i}\n$$\n\nAnd so on for higher orders of divided differences.\n\n### **Recursive Formula for Divided Differences**\n\nThe divided differences are computed recursively. For the first-order difference between two points, the formula is:\n\n$$\nf[x_i, x_{i+1}] = \\frac{f(x_{i+1}) - f(x_i)}{x_{i+1} - x_i}\n$$\n\nFor the second-order difference between three points:\n\n$$\nf[x_i, x_{i+1}, x_{i+2}] = \\frac{f[x_{i+1}, x_{i+2}] - f[x_i, x_{i+1}]}{x_{i+2} - x_i}\n$$\n\nThis recursive approach continues for higher orders of differences.\n\n### **Step-by-Step Construction of the Newton Polynomial**\n\n1. **Start with the first point** $(x_1, y_1)$, where $f[x_1] = y_1$.\n2. **First-order divided difference** between $(x_1, y_1)$ and $(x_2, y_2)$ is:\n\n$$\nf[x_1, x_2] = \\frac{y_2 - y_1}{x_2 - x_1}\n$$\n\n3. **Second-order divided difference** between $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$:\n\n$$\nf[x_1, x_2, x_3] = \\frac{f[x_2, x_3] - f[x_1, x_2]}{x_3 - x_1}\n$$\n\n4. Continue this process for higher-order divided differences.\n\nHere’s the corrected example in the same format as your original:\n\n### **Example**\n\nLet's consider the data points $(1, 1)$, $(2, 4)$, $(3, 9)$, and $(4, 16)$. The goal is to find the interpolating polynomial using Newton's divided differences.\n\n1. **First point**:\n\n$$\nf[1] = 1\n$$\n\n2. **First-order divided differences**:\n\n$$\nf[1, 2] = \\frac{4 - 1}{2 - 1} = 3\n$$\n\n$$\nf[2, 3] = \\frac{9 - 4}{3 - 2} = 5\n$$\n\n$$\nf[3, 4] = \\frac{16 - 9}{4 - 3} = 7\n$$\n\n3. **Second-order divided differences**:\n\n$$\nf[1, 2, 3] = \\frac{f[2, 3] - f[1, 2]}{3 - 1} = \\frac{5 - 3}{2} = 1\n$$\n\n$$\nf[2, 3, 4] = \\frac{f[3, 4] - f[2, 3]}{4 - 2} = \\frac{7 - 5}{2} = 1\n$$\n\n4. **Third-order divided difference**:\n\n$$\nf[1, 2, 3, 4] = \\frac{f[2, 3, 4] - f[1, 2, 3]}{4 - 1} = \\frac{1 - 1}{3} = 0\n$$\n\nNow, the Newton polynomial can be written as:\n\n$$\nP(x) = 1 + 3(x - 1) + 1(x - 1)(x - 2) + 0(x - 1)(x - 2)(x - 3)\n$$\n\nSimplifying:\n\n$$\nP(x) = 1 + 3(x - 1) + (x - 1)(x - 2)\n$$\n\nExpanding the terms:\n\n$$\nP(x) = 1 + 3x - 3 + (x^2 - 3x + 2)\n$$\n\nSimplifying further:\n\n$$\nP(x) = x^2\n$$\n\n### **General Properties of Newton's Divided Differences**\n\n1. **Efficiency**: Newton’s divided differences offer better computational efficiency when adding new points to the data set compared to Lagrange interpolation because earlier divided differences can be reused.\n\n2. **Uniqueness**: The Newton polynomial is unique, meaning for a given set of $n$ distinct points, there is exactly one polynomial of degree $n-1$ that interpolates the points.\n\n3. **Iterative Construction**: The method allows for iterative construction, which is useful when dealing with real-time updates or adding new data points.\n\n### **Applications of Newton’s Divided Differences**\n\n- **Polynomial Interpolation**: Newton’s divided differences are commonly used to find an interpolating polynomial for a given set of data points.\n- **Numerical Differentiation**: The method is used to approximate derivatives of functions when analytical differentiation is not feasible.\n- **Curve Fitting**: It is used in applications requiring curve fitting, especially in scientific computing and data analysis.\n\n### **Advantages of Newton’s Divided Differences**\n\n1. **Efficient for Incremental Data**: If you need to add a new data point, you don’t have to recompute the entire polynomial. Only the new divided differences need to be computed.\n\n2. **Easy to Implement**: The recursive approach to finding divided differences makes this method easy to implement in code.\n\n### **Limitations of Newton’s Divided Differences**\n\n1. **Numerical Stability**: Like other polynomial interpolation methods, Newton’s divided differences can suffer from numerical instability, especially with large datasets or unevenly spaced data.\n\n2. **Oscillations**: High-degree interpolating polynomials may oscillate significantly between data points, especially if the data is not well-distributed (similar to [**Runge's phenomenon**](../w03/runge-phenomenon.html)).\n\n### **Conclusion**\n\nNewton’s Divided Differences is a powerful method for constructing interpolating polynomials, especially when efficiency and incremental data updates are needed. Its recursive nature allows for fast updates when new data points are added, making it useful in applications such as numerical analysis, interpolation, and curve fitting.\n\n",
    "supporting": [
      "newtons-divided-differences_files"
    ],
    "filters": [],
    "includes": {}
  }
}