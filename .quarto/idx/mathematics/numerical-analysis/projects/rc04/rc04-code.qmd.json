{"title":"REALITY CHECK 04 - CODE","markdown":{"yaml":{"title":"REALITY CHECK 04 - CODE","author":"Nathan Lunceford","format":{"html":{"self-contained":true,"page-layout":"full","toc":true,"toc-depth":3,"toc-location":"right","number-sections":false,"html-math-method":"katex","embed-resources":true,"code-fold":true,"code-summary":"Show Code","code-overflow":"wrap","code-copy":"hover","code-tools":{"source":false,"toggle":true,"caption":"See code"}}},"engine":"jupyter","preview":{"port":3000,"browser":true,"watch-inputs":true,"navigate":true}},"headingText":"-----------------------------------------------------","containsRefs":false,"markdown":"\n\n```python\n#Import Libraries\nimport numpy as np\nfrom scipy.optimize import fsolve\nimport sympy as sp\n\n# PROBLEM 1: Numerical Root-Finding for GPS Positioning\n# -----------------------------------------------------\n\n# Given constants and satellite data\nc = 299792.458  # Speed of light in km/s\nA = [15600, 18760, 17610, 19170]  # Satellite x-coordinates in km\nB = [7540, 2750, 14630, 610]      # Satellite y-coordinates in km\nC = [20140, 18610, 13480, 18390]  # Satellite z-coordinates in km\nt = [0.07074, 0.07220, 0.07690, 0.07242]  # Signal travel times in seconds\n\n# Function to define the residuals for the nonlinear system\ndef residuals(vars):\n    \"\"\"\n    Residual function for GPS equations:\n    sqrt((x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2) - c * (t_i - d)\n    \"\"\"\n    x, y, z, d = vars  # Unpack the unknowns\n    res = []\n    for i in range(4):  # Loop through the 4 satellites\n        dist = np.sqrt((x - A[i])**2 + (y - B[i])**2 + (z - C[i])**2)\n        res.append(dist - c * (t[i] - d))  # Append each residual\n    return res\n\n# Initial guess for (x, y, z, d)\ninitial_guess = [0, 0, 6370.0, 0]  # Receiver near Earth's surface and d = 0\n\n# Solve the nonlinear system using fsolve\nsol = fsolve(residuals, initial_guess)\n\n# Print the solution for (x, y, z, d)\nprint(\"----- PROBLEM 1: Numerical Solution -----\")\nprint(f\"x = {sol[0]:.6f} km\")\nprint(f\"y = {sol[1]:.6f} km\")\nprint(f\"z = {sol[2]:.6f} km\")\nprint(f\"d = {sol[3]:.6e} seconds\")\nprint(\"-----------------------------------------\\n\")\n\n# ------------------------------------------------------------\n# PROBLEM 2: Determinant-Based Analytical Approach for GPS\n# ------------------------------------------------------------\n\n# Define symbolic variables\nx, y, z, d = sp.symbols('x y z d', real=True)\n\n# Formulate the nonlinear equations\neqs = []\nfor i in range(4):\n    eq = (x - A[i])**2 + (y - B[i])**2 + (z - C[i])**2 - (c * (t[i] - d))**2\n    eqs.append(eq)\n\n# Linearize the system\n# Subtract eqs[1], eqs[2], and eqs[3] from eqs[0] to eliminate x^2, y^2, z^2 terms\nlin_eqs = [sp.simplify(eqs[0] - eqs[i]) for i in range(1, 4)]\n\n# Extract the coefficients of the linear equations\nA_matrix, b_vector = sp.linear_eq_to_matrix(lin_eqs, [x, y, z, d])\n\n# Split the coefficient matrix into components:\nA_xyz = A_matrix[:, :3]  # Coefficients of x, y, z\nA_d = A_matrix[:, 3]     # Coefficient of d\n\n# Solve for x, y, z in terms of d\nxyz_solution = A_xyz.LUsolve(b_vector - A_d * d)\n\n# Simplify solutions for x, y, z as functions of d\nx_d = sp.simplify(xyz_solution[0])\ny_d = sp.simplify(xyz_solution[1])\nz_d = sp.simplify(xyz_solution[2])\n\n# Substitute x(d), y(d), z(d) into the first original equation\nquadratic_eq_d = sp.simplify(eqs[0].subs({x: x_d, y: y_d, z: z_d}))\n\n# Solve the resulting quadratic equation for d\ncoeffs_d = sp.Poly(quadratic_eq_d, d).all_coeffs()\nd_solutions = sp.solve(quadratic_eq_d, d)\n\n# Select the physically meaningful solution for d (real and close to zero)\nd_final = None\nfor candidate in d_solutions:\n    if candidate.is_real:\n        d_final = candidate.evalf()\n        break\n\n# Compute final (x, y, z) by substituting d into x_d, y_d, z_d\nx_final = x_d.subs(d, d_final).evalf()\ny_final = y_d.subs(d, d_final).evalf()\nz_final = z_d.subs(d, d_final).evalf()\n\n# Print the final analytical solution\nprint(\"----- PROBLEM 2: Analytical Solution -----\")\nprint(f\"x = {x_final:.6f} km\")\nprint(f\"y = {y_final:.6f} km\")\nprint(f\"z = {z_final:.6f} km\")\nprint(f\"d = {d_final:.6e} seconds\")\nprint(\"-----------------------------------------\")\n\n# ------------------------------------------------------------\n# PROBLEM 4 & 5: Conditioning Analysis of the GPS Problem\n# ------------------------------------------------------------\n\n# Constants\nc = 299792.458  # Speed of light in km/s\nrho = 26570  # Fixed satellite altitude in km\nreceiver_pos = np.array([0, 0, 6370])  # Receiver fixed at Earth's surface\nd_initial = 0.0001  # Initial clock bias\nperturbation = 1e-8  # Perturbation in seconds\n\n# Function to compute satellite positions in Cartesian coordinates\ndef compute_satellite_positions(phi, theta):\n    A = [rho * np.cos(p) * np.cos(t) for p, t in zip(phi, theta)]\n    B = [rho * np.cos(p) * np.sin(t) for p, t in zip(phi, theta)]\n    C = [rho * np.sin(p) for p in phi]\n    return np.array(A), np.array(B), np.array(C)\n\n# Compute nominal ranges and travel times\ndef compute_nominal_values(A, B, C):\n    R = np.sqrt((A - receiver_pos[0])**2 + (B - receiver_pos[1])**2 + (C - receiver_pos[2])**2)\n    t_nominal = d_initial + R / c\n    return R, t_nominal\n\n# GPS residual function\ndef gps_residuals(vars, t, A, B, C):\n    x, y, z, d = vars\n    residuals = np.sqrt((x - A)**2 + (y - B)**2 + (z - C)**2) - c * (t - d)\n    return residuals\n\n# EMF computation function\ndef compute_emf(t_perturbed, t_nominal, A, B, C):\n    initial_guess = [0, 0, 6370, d_initial]\n    sol_nominal = fsolve(gps_residuals, initial_guess, args=(t_nominal, A, B, C))\n    sol_perturbed = fsolve(gps_residuals, initial_guess, args=(t_perturbed, A, B, C))\n\n    position_error = np.linalg.norm(np.array(sol_perturbed[:3]) - np.array(sol_nominal[:3]))\n    input_error = np.linalg.norm(np.array(t_perturbed) - np.array(t_nominal)) * c\n    return position_error / input_error\n\n# Function to analyze EMF for given satellite configuration\ndef analyze_emf(phi, theta):\n    A, B, C = compute_satellite_positions(phi, theta)\n    _, t_nominal = compute_nominal_values(A, B, C)\n\n    emf_values = []\n    for i in range(4):\n        t_perturbed = t_nominal.copy()\n        t_perturbed[i] += perturbation\n        emf = compute_emf(t_perturbed, t_nominal, A, B, C)\n        emf_values.append(emf)\n\n    return emf_values\n\n# Loose satellite configuration\nphi_loose = [np.pi / 6, np.pi / 4, np.pi / 3, np.pi / 8]\ntheta_loose = [0, np.pi / 2, np.pi, 3 * np.pi / 2]\nemf_loose = analyze_emf(phi_loose, theta_loose)\n\n# Tightly grouped satellite configuration\ndef tightly_grouped_coordinates(phi_base, theta_base, perturb=0.05):\n    np.random.seed(42)  # For reproducibility\n    phi_tight = [phi_base * (1 + np.random.uniform(-perturb, perturb)) for _ in range(4)]\n    theta_tight = [theta_base * (1 + np.random.uniform(-perturb, perturb)) for _ in range(4)]\n    return phi_tight, theta_tight\n\nphi_base, theta_base = np.pi / 4, np.pi / 2\nphi_tight, theta_tight = tightly_grouped_coordinates(phi_base, theta_base)\nemf_tight = analyze_emf(phi_tight, theta_tight)\n\n# Print results\nprint(\"----- PROBLEM 4 & 5: CONDITIONING ANALYSIS COMPARISON -----\")\nprint(\"Loose Satellites:\")\nfor i, emf in enumerate(emf_loose):\n    print(f\"EMF for perturbation in t_{i+1}: {emf:.6f}\")\nprint(f\"Maximum EMF (Loose): {max(emf_loose):.6f}\\n\")\n\nprint(\"Tightly Grouped Satellites:\")\nfor i, emf in enumerate(emf_tight):\n    print(f\"EMF for perturbation in t_{i+1}: {emf:.6f}\")\nprint(f\"Maximum EMF (Tight): {max(emf_tight):.6f}\")\nprint(\"--------------------------------------------\")\n```\n","srcMarkdownNoYaml":"\n\n```python\n#Import Libraries\nimport numpy as np\nfrom scipy.optimize import fsolve\nimport sympy as sp\n\n# -----------------------------------------------------\n# PROBLEM 1: Numerical Root-Finding for GPS Positioning\n# -----------------------------------------------------\n\n# Given constants and satellite data\nc = 299792.458  # Speed of light in km/s\nA = [15600, 18760, 17610, 19170]  # Satellite x-coordinates in km\nB = [7540, 2750, 14630, 610]      # Satellite y-coordinates in km\nC = [20140, 18610, 13480, 18390]  # Satellite z-coordinates in km\nt = [0.07074, 0.07220, 0.07690, 0.07242]  # Signal travel times in seconds\n\n# Function to define the residuals for the nonlinear system\ndef residuals(vars):\n    \"\"\"\n    Residual function for GPS equations:\n    sqrt((x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2) - c * (t_i - d)\n    \"\"\"\n    x, y, z, d = vars  # Unpack the unknowns\n    res = []\n    for i in range(4):  # Loop through the 4 satellites\n        dist = np.sqrt((x - A[i])**2 + (y - B[i])**2 + (z - C[i])**2)\n        res.append(dist - c * (t[i] - d))  # Append each residual\n    return res\n\n# Initial guess for (x, y, z, d)\ninitial_guess = [0, 0, 6370.0, 0]  # Receiver near Earth's surface and d = 0\n\n# Solve the nonlinear system using fsolve\nsol = fsolve(residuals, initial_guess)\n\n# Print the solution for (x, y, z, d)\nprint(\"----- PROBLEM 1: Numerical Solution -----\")\nprint(f\"x = {sol[0]:.6f} km\")\nprint(f\"y = {sol[1]:.6f} km\")\nprint(f\"z = {sol[2]:.6f} km\")\nprint(f\"d = {sol[3]:.6e} seconds\")\nprint(\"-----------------------------------------\\n\")\n\n# ------------------------------------------------------------\n# PROBLEM 2: Determinant-Based Analytical Approach for GPS\n# ------------------------------------------------------------\n\n# Define symbolic variables\nx, y, z, d = sp.symbols('x y z d', real=True)\n\n# Formulate the nonlinear equations\neqs = []\nfor i in range(4):\n    eq = (x - A[i])**2 + (y - B[i])**2 + (z - C[i])**2 - (c * (t[i] - d))**2\n    eqs.append(eq)\n\n# Linearize the system\n# Subtract eqs[1], eqs[2], and eqs[3] from eqs[0] to eliminate x^2, y^2, z^2 terms\nlin_eqs = [sp.simplify(eqs[0] - eqs[i]) for i in range(1, 4)]\n\n# Extract the coefficients of the linear equations\nA_matrix, b_vector = sp.linear_eq_to_matrix(lin_eqs, [x, y, z, d])\n\n# Split the coefficient matrix into components:\nA_xyz = A_matrix[:, :3]  # Coefficients of x, y, z\nA_d = A_matrix[:, 3]     # Coefficient of d\n\n# Solve for x, y, z in terms of d\nxyz_solution = A_xyz.LUsolve(b_vector - A_d * d)\n\n# Simplify solutions for x, y, z as functions of d\nx_d = sp.simplify(xyz_solution[0])\ny_d = sp.simplify(xyz_solution[1])\nz_d = sp.simplify(xyz_solution[2])\n\n# Substitute x(d), y(d), z(d) into the first original equation\nquadratic_eq_d = sp.simplify(eqs[0].subs({x: x_d, y: y_d, z: z_d}))\n\n# Solve the resulting quadratic equation for d\ncoeffs_d = sp.Poly(quadratic_eq_d, d).all_coeffs()\nd_solutions = sp.solve(quadratic_eq_d, d)\n\n# Select the physically meaningful solution for d (real and close to zero)\nd_final = None\nfor candidate in d_solutions:\n    if candidate.is_real:\n        d_final = candidate.evalf()\n        break\n\n# Compute final (x, y, z) by substituting d into x_d, y_d, z_d\nx_final = x_d.subs(d, d_final).evalf()\ny_final = y_d.subs(d, d_final).evalf()\nz_final = z_d.subs(d, d_final).evalf()\n\n# Print the final analytical solution\nprint(\"----- PROBLEM 2: Analytical Solution -----\")\nprint(f\"x = {x_final:.6f} km\")\nprint(f\"y = {y_final:.6f} km\")\nprint(f\"z = {z_final:.6f} km\")\nprint(f\"d = {d_final:.6e} seconds\")\nprint(\"-----------------------------------------\")\n\n# ------------------------------------------------------------\n# PROBLEM 4 & 5: Conditioning Analysis of the GPS Problem\n# ------------------------------------------------------------\n\n# Constants\nc = 299792.458  # Speed of light in km/s\nrho = 26570  # Fixed satellite altitude in km\nreceiver_pos = np.array([0, 0, 6370])  # Receiver fixed at Earth's surface\nd_initial = 0.0001  # Initial clock bias\nperturbation = 1e-8  # Perturbation in seconds\n\n# Function to compute satellite positions in Cartesian coordinates\ndef compute_satellite_positions(phi, theta):\n    A = [rho * np.cos(p) * np.cos(t) for p, t in zip(phi, theta)]\n    B = [rho * np.cos(p) * np.sin(t) for p, t in zip(phi, theta)]\n    C = [rho * np.sin(p) for p in phi]\n    return np.array(A), np.array(B), np.array(C)\n\n# Compute nominal ranges and travel times\ndef compute_nominal_values(A, B, C):\n    R = np.sqrt((A - receiver_pos[0])**2 + (B - receiver_pos[1])**2 + (C - receiver_pos[2])**2)\n    t_nominal = d_initial + R / c\n    return R, t_nominal\n\n# GPS residual function\ndef gps_residuals(vars, t, A, B, C):\n    x, y, z, d = vars\n    residuals = np.sqrt((x - A)**2 + (y - B)**2 + (z - C)**2) - c * (t - d)\n    return residuals\n\n# EMF computation function\ndef compute_emf(t_perturbed, t_nominal, A, B, C):\n    initial_guess = [0, 0, 6370, d_initial]\n    sol_nominal = fsolve(gps_residuals, initial_guess, args=(t_nominal, A, B, C))\n    sol_perturbed = fsolve(gps_residuals, initial_guess, args=(t_perturbed, A, B, C))\n\n    position_error = np.linalg.norm(np.array(sol_perturbed[:3]) - np.array(sol_nominal[:3]))\n    input_error = np.linalg.norm(np.array(t_perturbed) - np.array(t_nominal)) * c\n    return position_error / input_error\n\n# Function to analyze EMF for given satellite configuration\ndef analyze_emf(phi, theta):\n    A, B, C = compute_satellite_positions(phi, theta)\n    _, t_nominal = compute_nominal_values(A, B, C)\n\n    emf_values = []\n    for i in range(4):\n        t_perturbed = t_nominal.copy()\n        t_perturbed[i] += perturbation\n        emf = compute_emf(t_perturbed, t_nominal, A, B, C)\n        emf_values.append(emf)\n\n    return emf_values\n\n# Loose satellite configuration\nphi_loose = [np.pi / 6, np.pi / 4, np.pi / 3, np.pi / 8]\ntheta_loose = [0, np.pi / 2, np.pi, 3 * np.pi / 2]\nemf_loose = analyze_emf(phi_loose, theta_loose)\n\n# Tightly grouped satellite configuration\ndef tightly_grouped_coordinates(phi_base, theta_base, perturb=0.05):\n    np.random.seed(42)  # For reproducibility\n    phi_tight = [phi_base * (1 + np.random.uniform(-perturb, perturb)) for _ in range(4)]\n    theta_tight = [theta_base * (1 + np.random.uniform(-perturb, perturb)) for _ in range(4)]\n    return phi_tight, theta_tight\n\nphi_base, theta_base = np.pi / 4, np.pi / 2\nphi_tight, theta_tight = tightly_grouped_coordinates(phi_base, theta_base)\nemf_tight = analyze_emf(phi_tight, theta_tight)\n\n# Print results\nprint(\"----- PROBLEM 4 & 5: CONDITIONING ANALYSIS COMPARISON -----\")\nprint(\"Loose Satellites:\")\nfor i, emf in enumerate(emf_loose):\n    print(f\"EMF for perturbation in t_{i+1}: {emf:.6f}\")\nprint(f\"Maximum EMF (Loose): {max(emf_loose):.6f}\\n\")\n\nprint(\"Tightly Grouped Satellites:\")\nfor i, emf in enumerate(emf_tight):\n    print(f\"EMF for perturbation in t_{i+1}: {emf:.6f}\")\nprint(f\"Maximum EMF (Tight): {max(emf_tight):.6f}\")\nprint(\"--------------------------------------------\")\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true,"caption":"See code"},"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../../styles.css"],"toc":true,"self-contained":true,"toc-depth":3,"number-sections":false,"html-math-method":"katex","embed-resources":true,"output-file":"rc04-code.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":{"light":"flatly","dark":"darkly"},"title":"REALITY CHECK 04 - CODE","author":"Nathan Lunceford","preview":{"port":3000,"browser":true,"watch-inputs":true,"navigate":true},"page-layout":"full","toc-location":"right","code-summary":"Show Code","code-copy":"hover"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}