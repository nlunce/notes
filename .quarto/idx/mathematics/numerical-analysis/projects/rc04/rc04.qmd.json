{"title":"REALITY CHECK 04","markdown":{"yaml":{"title":"REALITY CHECK 04","author":"Nathan Lunceford","format":{"html":{"self-contained":true,"page-layout":"full","toc":true,"toc-depth":3,"toc-location":"right","number-sections":true,"number-depth":3,"html-math-method":"katex","embed-resources":true,"code-fold":true,"code-summary":"Show Code","code-overflow":"wrap","code-copy":"hover","code-tools":{"source":false,"toggle":true,"caption":"See code"}}},"engine":"jupyter","preview":{"port":3000,"browser":true,"watch-inputs":true,"navigate":true}},"headingText":"**Overview**","containsRefs":false,"markdown":"\n\n```{python}\n#| label: libraries\n#| include: false\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import quad\nfrom functools import lru_cache\nimport time\n```\n\n\nThe Global Positioning System (GPS) is a satellite-based navigation system consisting of 24 satellites equipped with atomic clocks, orbiting the Earth at an altitude of 20,200 km. By measuring the travel time of signals transmitted from satellites to a receiver, GPS calculates the receiver's position in three-dimensional space. Each signal defines a sphere with a radius equal to the distance traveled by the signal, and the receiver's position is at the intersection of these spheres.\n\nTo determine an accurate position $(x, y, z)$ and synchronize the receiver’s clock, at least four satellites are required. The system of nonlinear equations representing the sphere intersections can be formulated as:\n\n$$\nr_i(x, y, z, d) = \\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} - c(t_i - d) = 0\n$$\n\nwhere $d$ is a clock correction factor for the receiver. Solving this system reveals both the receiver’s coordinates and the corrected clock time.\n\nHowever, the system faces challenges due to:\n\n1. **Receiver Clock Inaccuracy**: Affordable GPS receivers lack the precision of satellite atomic clocks, necessitating the inclusion of $d$ in the equations.\n2. **Ill-Conditioning**: The system becomes sensitive to errors when satellites are clustered close together in the sky.\n3. **Environmental Factors**: Signal transmission speed is affected by atmospheric interference and obstacles, introducing further inaccuracies.\n\nTo address these challenges:\n\n- **Numerical Root-Finding Methods** (e.g., Newton-Krylov, Gauss-Newton) iteratively solve the equations but can struggle with sensitivity to initial guesses and ill-conditioning.\n- **Error Analysis** evaluates the system's sensitivity to input timing errors, quantified through the **Error Magnification Factor (EMF)**, which assesses the impact of small changes in signal timing on positional accuracy.\n\nBy leveraging precise satellite positions and signal timing data, this system provides accurate navigation but requires advanced mathematical techniques to manage inherent nonlinearities and ensure robustness. This report focuses on exploring and solving the GPS positioning problem through numerical and analytical approaches, providing insights into accuracy, stability, and efficiency.\n\n# **Numerical Root-Finding Approach to GPS Positioning**\n\n## **Objective**\n\nThe objective of this study is to calculate the position of a GPS receiver $(x, y, z)$ and correct the receiver's clock bias $d$ by solving a system of nonlinear equations. These equations model the distance between the receiver and multiple satellites based on signal travel times. The numerical solution relies on iterative root-finding methods to achieve high accuracy.\n\n## **Background**\n\nIn a GPS system, the position of a receiver is determined by measuring the time it takes for signals to travel from multiple satellites. The propagation time, when multiplied by the speed of light $c$, provides the distance between the satellite and the receiver. Mathematically, the relationship between the receiver's unknown position $(x, y, z)$ and the clock correction $d$ is expressed as a system of nonlinear equations:\n\n$$\n\\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} = c(t_i - d), \\quad i = 1, 2, 3, 4\n$$\n\nWhere:\n\n- $(A_i, B_i, C_i)$ are the known satellite positions.\n- $t_i$ are the measured signal travel times.\n- $c \\approx 299,792.458 \\, \\text{km/s}$ is the speed of light.\n- $(x, y, z)$ are the unknown receiver coordinates.\n- $d$ is the receiver clock correction.\n\nEach equation corresponds to a sphere centered at the satellite's position, with the radius equal to the computed distance. The receiver's position lies at the intersection of these spheres. The inclusion of $d$ accounts for the clock bias in the receiver, which is less precise than the atomic clocks onboard GPS satellites.\n\n## **Methodology**\n\nA numerical root-finding approach is employed to solve this system of nonlinear equations. Specifically, Python's `fsolve` function from the `scipy.optimize` library is utilized. This method iteratively refines estimates for $(x, y, z, d)$ until the residuals—the differences between the measured and calculated distances—are minimized.\n\n### **Formulation of the Problem**\n\nThe system of equations is reformulated as residual functions $f_i$, where each function evaluates to zero when the system is satisfied:\n\n$$\nf_i(x, y, z, d) = \\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} - c(t_i - d), \\quad i = 1, 2, 3, 4\n$$\n\nThe root-finding process involves solving for $(x, y, z, d)$ such that all $f_i(x, y, z, d) = 0$.\n\n### **Numerical Solution**\n\nThe computational steps are as follows:\n\n1. **Input Data:** Known satellite positions $(A_i, B_i, C_i)$ and signal travel times $t_i$ are provided as inputs, along with the speed of light $c$.\n2. **Initial Guess:** A starting point of $(x_0, y_0, z_0) = (0, 0, 6370)$ km is assumed, placing the receiver near the Earth's surface. The initial clock correction is set to $d_0 = 0$.\n3. **Iterative Solver:** The `fsolve` function iteratively adjusts $(x, y, z, d)$ to minimize the residuals $f_i$. The algorithm terminates when all residuals approach zero, indicating convergence to a solution.\n\nThe implementation was tested using the following dataset:\n\n- Satellite positions:\n\n  - $(15,600, 7,540, 20,140)$\n  - $(18,760, 2,750, 18,610)$\n  - $(17,610, 14,630, 13,480)$\n  - $(19,170, 610, 18,390)$\n\n- Signal travel times:\n  $$\n  t = [0.07074, 0.07220, 0.07690, 0.07242] \\, \\text{(in seconds)}\n  $$\n\n::: {.callout-tip}\n\n### Accompanying Code\n\nThe [**accompanying code implementation**](./rc04-code.html) defines the residual function, applies the `fsolve` solver, and outputs the computed results.\n:::\n\n## **Results**\n\nThe numerical root-finding method produced the following results:\n\n- **Receiver Position (in km):**\n  $$\n  (x, y, z) = (-41.77271, -16.78919, 6370.0596)\n  $$\n- **Clock Correction (in seconds):**\n  $$\n  d = -3.201566 \\times 10^{-3}\n  $$\n\nThese values were verified against expected results, confirming the accuracy of the numerical solution. The computed receiver position aligns with the Earth's surface, and the clock correction accounts for the slight bias in the receiver's timing.\n\n## **Limitations**\n\nWhile the numerical root-finding approach proved effective, several limitations should be noted:\n\n1. **Sensitivity to Ill-Conditioning:** The system may become ill-conditioned when satellite positions are clustered, amplifying numerical errors and reducing accuracy.\n2. **Dependence on Initial Guesses:** Poor initial guesses can lead to non-convergence or convergence to an incorrect solution.\n3. **Computational Cost:** Iterative methods like `fsolve` require multiple evaluations of the residuals, making them computationally expensive for real-time applications.\n4. **Lack of Analytical Insights:** The numerical solution provides no explicit relationships between the variables, limiting its use for sensitivity analysis or theoretical exploration.\n\n## **Motivation for an Improved Approach**\n\nThe limitations of the numerical root-finding method highlight the need for a more robust and efficient solution. Specifically:\n\n- A method that avoids iterative guesswork.\n- Improved handling of ill-conditioned systems.\n- A more **analytical approach** that isolates variables and reduces the problem complexity.\n\nTo address these concerns, the next section introduces a **determinant-based analytical approach**. This method linearizes the system of equations, isolates variables explicitly, and reduces the problem to solving a single quadratic equation for the clock correction $d$. It offers both computational efficiency and greater stability, making it well-suited for real-time GPS positioning.\n\n## **Conclusion**\n\nThe numerical root-finding approach provides an approximate solution to the GPS equations but is limited by its sensitivity, inefficiency, and lack of robustness. These shortcomings motivate the need for an improved analytical method, which will be explored in the following section.\n\n# **Determinant-Based Analytical Approach to GPS Positioning**\n\n## **Objective**\n\nThe objective of this section is to solve the GPS equations **analytically** using a **determinant-based approach**. Unlike numerical root-finding methods, this analytical technique avoids iterative guesswork by isolating the variables $(x, y, z, d)$ explicitly. By systematically transforming the original nonlinear system into a more manageable linear form, this method ensures greater robustness, stability, and computational efficiency—critical for real-time or precision GPS applications.\n\nThe approach has been implemented in Python using the **SymPy** library to symbolically manipulate the equations, solve the system, and isolate the unknowns step-by-step.\n\n## **Problem Formulation**\n\nThe GPS receiver’s position $(x, y, z)$ and clock offset $d$ are determined from four satellite equations of the form:\n\n$$\n\\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} = c(t_i - d), \\quad i = 1, 2, 3, 4\n$$\n\nHere:\n\n- $(A_i, B_i, C_i)$ are known satellite coordinates.\n- $t_i$ are measured signal travel times.\n- $c \\approx 299792.458\\,\\text{km/s}$ is the speed of light.\n- $(x, y, z)$ and $d$ are the unknown receiver coordinates and clock correction.\n\nEach equation represents a sphere with the satellite at its center. The receiver lies at the intersection of these four spheres. However, the presence of square roots and the unknown $d$ makes the system inherently nonlinear and challenging to solve directly.\n\n## **Methodology**\n\n::: {.callout-tip}\n\n### Code Implementation\n\nThe solution process involves three key stages, all of which are implemented in the accompanying [Python code](./rc04-code.html).\n:::\n\n### **Reducing the Nonlinear System to a Linear Form**\n\nTo eliminate the square roots, we square each equation. After doing so, we have:\n\n$$\n(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2 = c^2(t_i - d)^2\n$$\n\nWe then **subtract the equations for satellites $i=2,3,4$ from the equation for $i=1$**. This subtraction removes the $x^2 + y^2 + z^2$ terms and results in three linear equations in the four unknowns $x, y, z, d$:\n\n$$\nx u_{x}^{(j)} + y u_{y}^{(j)} + z u_{z}^{(j)} + d u_{d}^{(j)} + w^{(j)} = 0,\\quad j=1,2,3\n$$\n\nwhere $u_x^{(j)}, u_y^{(j)}, u_z^{(j)}, u_d^{(j)}, w^{(j)}$ are constants determined by the satellite positions and travel times.\n\nAt this point, we have **three linear equations** with **four unknowns**:\n\n$$\nx u_{x1} + y u_{y1} + z u_{z1} + d u_{d1} + w_1 = 0\n$$\n\n$$\nx u_{x2} + y u_{y2} + z u_{z2} + d u_{d2} + w_2 = 0\n$$\n\n$$\nx u_{x3} + y u_{y3} + z u_{z3} + d u_{d3} + w_3 = 0\n$$\n\n::: {.callout-tip}\n\n### Accompanying Code\n\nIn the accompanying code, this system of equations is constructed symbolically using **SymPy**, with the `simplify()` function applied to ensure clarity and precision in the linearized expressions.\n:::\n\n#### **Why Solve for the Variables in Terms of $d$?**\n\n---\n\nWith three linear equations and four unknowns, the system is underdetermined. We cannot directly solve for all four variables at once. To proceed, we:\n\n- Treat $d$ as a parameter.\n- Express $x, y, z$ as linear functions of $d$:\n\n  $$\n  x = f_x(d), \\quad y = f_y(d), \\quad z = f_z(d)\n  $$\n\nOnce $x, y, z$ are known in terms of $d$, we substitute these functions back into one of the original nonlinear equations. This will yield a **single quadratic equation in $d$**. Solving that quadratic equation gives us $d$. With $d$ in hand, we easily find $x, y, z$.\n\nThis approach reduces the complexity: instead of trying to solve four nonlinear equations simultaneously, we simplify the problem to solving one quadratic equation after isolating variables in terms of $d$.\n\n#### **Introducing the Determinant Equation**\n\n---\n\nTo isolate $x, y, z$ in terms of $d$, we use a **determinant-based approach**. Determinants are a powerful linear algebra tool. By arranging our linear equations in a matrix form and considering certain determinants, we can:\n\n- Identify linear dependencies,\n- Isolate one variable at a time,\n- Avoid ambiguity and instability.\n\nThe idea is to construct a determinant from the system of equations and carefully manipulate it so that one variable (e.g., $x$) can be extracted in terms of $y, z, d$ and constants. We then repeat or apply a similar reasoning for $y$ and $z$.\n\n### **Isolating $x$ in Terms of $d$ Using the Determinant**\n\n**Step-by-Step for $x$:**\n\n1. **Set Up the Determinant:**\n\n   Consider a matrix formed from the coefficient vectors $\\mathbf{u_x}, \\mathbf{u_y}, \\mathbf{u_z}, \\mathbf{u_d}, \\mathbf{w}$. A key construction is:\n\n   $$\n    \\det[\\mathbf{u_y} \\mid \\mathbf{u_z} \\mid x\\mathbf{u_x} + y\\mathbf{u_y} + z\\mathbf{u_z} + d\\mathbf{u_d} + \\mathbf{w}] = 0\n   $$\n\n   This determinant equals zero because if $-\\mathbf{w}$ lies in the span of the other vectors, the system is consistent. Expanding this determinant along the third column will separate terms involving $x, y, z, d$.\n\n   $$\n   \\text{det} \\begin{bmatrix}\n   u_{y1} & u_{z1} & x u_{x1} + y u_{y1} + z u_{z1} + d u_{d1} + w_1 \\\\\n   u_{y2} & u_{z2} & x u_{x2} + y u_{y2} + z u_{z2} + d u_{d2} + w_2 \\\\\n   u_{y3} & u_{z3} & x u_{x3} + y u_{y3} + z u_{z3} + d u_{d3} + w_3\n   \\end{bmatrix} = 0\n   $$\n\n2. **Expand the Determinant**:  \n   Expanding along the third column gives:\n\n   $$\n   \\text{det}[\\dots] = (x u_{x1} + y u_{y1} + z u_{z1} + d u_{d1} + w_1) \\cdot \\text{det} \\begin{bmatrix}\n   u_{y2} & u_{z2} \\\\\n   u_{y3} & u_{z3}\n   \\end{bmatrix}\n   $$\n\n   $$\n   - (x u_{x2} + y u_{y2} + z u_{z2} + d u_{d2} + w_2) \\cdot \\text{det} \\begin{bmatrix}\n   u_{y1} & u_{z1} \\\\\n   u_{y3} & u_{z3}\n   \\end{bmatrix}\n   $$\n\n   $$\n   + (x u_{x3} + y u_{y3} + z u_{z3} + d u_{d3} + w_3) \\cdot \\text{det} \\begin{bmatrix}\n   u_{y1} & u_{z1} \\\\\n   u_{y2} & u_{z2}\n   \\end{bmatrix}\n   $$\n\n3. **Group Terms Involving $x, y, z, d$**:  \n   Collect coefficients for each variable. For example for $x$, the coefficient $C_x$ is:\n\n   $$\n   C_x = u_{x1} \\cdot \\text{det} \\begin{bmatrix}\n   u_{y2} & u_{z2} \\\\\n   u_{y3} & u_{z3}\n   \\end{bmatrix}\n   - u_{x2} \\cdot \\text{det} \\begin{bmatrix}\n   u_{y1} & u_{z1} \\\\\n   u_{y3} & u_{z3}\n   \\end{bmatrix}\n   + u_{x3} \\cdot \\text{det} \\begin{bmatrix}\n   u_{y1} & u_{z1} \\\\\n   u_{y2} & u_{z2}\n   \\end{bmatrix}\n   $$\n\n   On expansion, you get an equation of the form:\n\n   $$\n   C_x x + C_y y + C_z z + C_d d + T = 0\n   $$\n\n   where $C_x, C_y, C_z, C_d, T$ are combinations of determinants and known constants derived from the satellite data.\n\n4. **Isolate $x$:**\n\n   To solve for $x$, rearrange the equation:\n\n   $$\n   x = -\\frac{C_y y + C_z z + C_d d + T}{C_x}\n   $$\n\n   However, at this stage, $x$ is still expressed in terms of $y, z, d$. To get $x$ purely in terms of $d$, you must similarly isolate $y$ and $z$ in terms of $d$.\n\n5. **Repeat for $y$ and $z$:**\n\n   By constructing similar determinant equations and performing analogous expansions, you isolate $y$ and $z$ as linear functions of $d$:\n\n   $$\n   y = f_y(d), \\quad z = f_z(d)\n   $$\n\n   Once $y(d)$ and $z(d)$ are known, substitute them back into the expression for $x$:\n\n   $$\n   x = f_x(d)\n   $$\n\n   Now all three spatial variables are functions of $d$:\n\n   $$\n   x = f_x(d), \\quad y = f_y(d), \\quad z = f_z(d)\n   $$\n\n::: {.callout-tip}\n\n### Accompanying Code\n\nThe accompanying code uses SymPy’s `linear_eq_to_matrix` to extract the coefficient matrix and split it into parts:\n\n- $A_{xyz}$: Coefficients for $x, y, z$,\n- $A_d$: Coefficients for $d$.\n\nThe resulting system is:\n\n$$\nA\\_{xyz} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} = -A_d d - \\mathbf{w}.\n$$\n\nSolving this system for $x$, $y$, and $z$ in terms of $d$ is achieved using the `LUsolve` function. The symbolic solutions $x(d)$, $y(d)$, and $z(d)$ are simplified and stored.\n:::\n\n### **Forming the Quadratic Equation in $d$**\n\nWith $x(d), y(d), z(d)$ established, we return to an original nonlinear equation. For example:\n\n$$\n\\sqrt{(x - A_1)^2 + (y - B_1)^2 + (z - C_1)^2} = c(t_1 - d)\n$$\n\n- Substitute $x(d), y(d), z(d)$ into the left-hand side.\n- Square both sides to remove the square root.\n\nAfter simplification, you obtain a **quadratic equation in $d$**:\n\n$$\na d^2 + b d + c = 0\n$$\n\nSolving this quadratic equation using the quadratic formula:\n\n$$\nd = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n$$\n\nChoose the physically meaningful solution for $d$ (the one placing the receiver near Earth’s surface), then substitute $d$ back into $x(d), y(d), z(d)$ to find the final coordinates $(x, y, z)$.\n\n::: {.callout-tip}\n\n### Accompanying Code\n\n1. Once $x(d)$, $y(d)$, and $z(d)$ are known, they are substituted back into one of the original nonlinear equations (e.g., the first equation). This substitution is performed symbolically in the code using `subs()`.\n\n2. Simplifying the resulting equation produces a **quadratic equation in $d$**:\n\n$$\na d^2 + b d + c = 0.\n$$\n\n3. The coefficients of the quadratic equation are extracted using SymPy's `Poly` and `all_coeffs` functions. The quadratic formula is then applied to solve for $d$.\n\n4. Among the solutions for $d$, the physically meaningful (real and close to zero) solution is selected. This step is automated in the code by evaluating the solutions and filtering for real roots.\n\n5. The final values of $x$, $y$, and $z$ are computed by substituting the selected $d$ back into $x(d)$, $y(d)$, and $z(d)$.\n\n**Results**\n\nThe determinant-based analytical approach produces the following results:\n\n- **Receiver Position (in km):**\n  $$\n  (x, y, z) = (-41.77271, -16.78919, 6370.0596)\n  $$\n- **Clock Correction (in seconds):**\n  $$\n  d = -3.201566 \\times 10^{-3}.\n  $$\n\nThese results are consistent with the numerical solutions obtained in **numerical root-finding approach**, confirming the correctness of the analytical method.\n:::\n\n## **Conclusion**\n\nThis determinant-based analytical approach transforms the original nonlinear GPS equations into a linearized problem, uses determinants to isolate $x, y, z$ in terms of $d$, and ultimately reduces the entire system to solving a single quadratic equation in $d$.\n\n**Key Advantages:**\n\n- No iterative guesswork required, avoiding convergence issues.\n- More stable and robust, especially when satellites are poorly distributed.\n- Provides a closed-form, analytical solution, offering deeper insight and efficiency.\n\nBy following these steps—reducing to a linear system, isolating variables in terms of $d$ using determinants, and forming a single quadratic in $d$—we obtain a direct and reliable solution to the GPS positioning problem.\n\n# **Conditioning Analysis of the GPS System**\n\n## **Objective**\n\nThe objective of this section is to evaluate how the **conditioning** of the GPS system changes when the satellite positions are either **loosely distributed** or **tightly grouped**. Sensitivity to small errors in signal travel times $t_i$ is analyzed using the **Error Magnification Factor (EMF)**. By comparing EMF values for both configurations, we identify how satellite geometry impacts the robustness and stability of the GPS positioning system.\n\n## **Background**\n\n### **GPS Sensitivity and Conditioning**\n\nIn GPS systems, small timing errors $\\Delta t_i$ in the satellite signals can result in significant positional errors. These errors arise from the **ill-conditioning** of the system of equations, which occurs when satellite positions are geometrically clustered.\n\nThe system is analyzed by:\n\n1. **Introducing Perturbations**: A small timing error $\\Delta t_i \\approx 10^{-8} \\, \\text{s}$ (equivalent to $3 \\, \\text{meters}$) is applied to each signal.\n2. **Forward Error**: The resulting change in the computed position is measured as:\n   $$\n   \\|\\Delta x, \\Delta y, \\Delta z\\|_2 = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n   $$\n3. **Error Magnification Factor (EMF)**: The EMF quantifies the sensitivity of the system to perturbations:\n   $$\n   \\text{EMF} = \\frac{\\|\\Delta x, \\Delta y, \\Delta z\\|_2}{c \\, \\|\\Delta t_i\\|_2}\n   $$\n   A **higher EMF** indicates a poorly conditioned system.\n\n### **Satellite Geometry**\n\n- **Loosely Distributed Satellites**: Satellites are widely spaced across the sky, providing better geometric diversity. This reduces ill-conditioning and improves robustness.\n- **Tightly Grouped Satellites**: Satellites are close together (within 5% of one another in spherical coordinates), leading to **geometric correlation** and increased sensitivity to timing errors.\n\n## **Methodology**\n\n### **Steps to Solve**\n\nThe analysis was conducted as follows:\n\n1. **Satellite Position Generation**:\n\n   - Loosely distributed satellites were generated using diverse spherical coordinates ($\\phi$ and $\\theta$).\n   - Tightly grouped satellites were generated by restricting both $\\phi_i$ and $\\theta_i$ within 5% of one another.\n\n2. **Nominal and Perturbed Signal Times**:\n\n   - For both configurations, nominal signal travel times $t_i$ were calculated based on the range:\n     $$\n     R_i = \\sqrt{A_i^2 + B_i^2 + (C_i - 6370)^2}, \\quad t_i = d + \\frac{R_i}{c}\n     $$\n   - Each $t_i$ was perturbed by $10^{-8} \\, \\text{s}$, while other times were held constant.\n\n3. **Solve for Position**:\n\n   - The GPS equations were solved numerically using `fsolve` for both nominal and perturbed travel times.\n   - The positional error $\\|\\Delta x, \\Delta y, \\Delta z\\|_2$ was computed for each perturbation.\n\n4. **Calculate EMF**:  \n   The EMF was calculated using the formula:\n\n   $$\n   \\text{EMF} = \\frac{\\|\\Delta x, \\Delta y, \\Delta z\\|_2}{c \\, \\|\\Delta t_i\\|_2}\n   $$\n\n5. **Compare Results**:  \n   EMF values were compared for both the loosely distributed and tightly grouped satellite configurations.\n\n::: {.callout-tip}\n\n### **Accompanying Code**\n\nThe [accompanying code](./rc04-code.html) performs the following steps:\n\n1. **Generate Satellite Positions**:\n\n   - Loosely spaced satellites use diverse $\\phi$ and $\\theta$ values.\n   - Tightly grouped satellites have $\\phi$ and $\\theta$ within 5% of each other.\n\n2. **Calculate Ranges and Times**:  \n   Nominal ranges $R_i$ and travel times $t_i$ are computed.\n\n3. **Introduce Perturbations**:  \n   Each signal time $t_i$ is perturbed by $10^{-8} \\, \\text{s}$, and the GPS equations are solved numerically using `fsolve`.\n\n4. **Compute Forward Error and EMF**:\n\n   - The positional error is computed as the Euclidean distance between the nominal and perturbed positions.\n   - EMF values are calculated for each perturbation.\n\n5. **Comparison of Configurations**:  \n   EMF values for loosely and tightly grouped satellites are compared, and the maximum EMF is identified.\n\n:::\n\n## **Results**\n\nThe results of the EMF analysis for both satellite configurations are as follows:\n\n### **Loose Satellites**\n\n| Perturbation in $t_i$ | EMF Value |\n| --------------------- | --------- |\n| $t_1$                 | 2.207538  |\n| $t_2$                 | 2.828432  |\n| $t_3$                 | 2.856126  |\n| $t_4$                 | 2.203932  |\n\n**Maximum EMF**:\n\n$$\n\\text{EMF}_{\\text{max}} = 2.856126\n$$\n\n### **Tightly Grouped Satellites**\n\n| Perturbation in $t_i$ | EMF Value   |\n| --------------------- | ----------- |\n| $t_1$                 | 1553.480087 |\n| $t_2$                 | 2317.787515 |\n| $t_3$                 | 3402.498373 |\n| $t_4$                 | 466.068303  |\n\n**Maximum EMF**:\n\n$$\n\\text{EMF}_{\\text{max}} = 3402.498373\n$$\n\n### **Comparison**\n\n| Configuration        | EMF Range   | Maximum EMF | Sensitivity |\n| -------------------- | ----------- | ----------- | ----------- |\n| **Loose Satellites** | 2.2 to 2.8  | 2.856126    | Low         |\n| **Tightly Grouped**  | 466 to 3402 | 3402.498373 | Very High   |\n\n## **Interpretation**\n\nThe results demonstrate a clear relationship between satellite geometry and the conditioning of the GPS system:\n\n1. **Loose Satellites**:\n\n   - EMF values remain low (around 2–3), indicating that the system is **well-conditioned**.\n   - Perturbations in signal times result in small position errors due to the geometric diversity of the satellites.\n\n2. **Tightly Grouped Satellites**:\n   - EMF values increase dramatically (up to 3402), showing that the system becomes **ill-conditioned**.\n   - Small input errors are significantly amplified, leading to large position errors.\n   - This sensitivity arises from the satellites’ correlated geometry, where their signals cannot provide sufficient independent information.\n\n## **Conclusion**\n\nThis analysis highlights the critical role of satellite geometry in the conditioning of the GPS system:\n\n- Loosely distributed satellites provide better geometric diversity and robustness, resulting in lower EMF values and greater accuracy.\n- Tightly grouped satellites lead to poor conditioning, amplifying errors and making the system highly sensitive to small perturbations in signal travel times.\n\nTo ensure accurate and stable GPS positioning, it is essential to use satellites with diverse spatial distributions. This insight is particularly valuable for optimizing satellite selection algorithms in GPS receivers.\n","srcMarkdownNoYaml":"\n\n```{python}\n#| label: libraries\n#| include: false\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import quad\nfrom functools import lru_cache\nimport time\n```\n\n## **Overview**\n\nThe Global Positioning System (GPS) is a satellite-based navigation system consisting of 24 satellites equipped with atomic clocks, orbiting the Earth at an altitude of 20,200 km. By measuring the travel time of signals transmitted from satellites to a receiver, GPS calculates the receiver's position in three-dimensional space. Each signal defines a sphere with a radius equal to the distance traveled by the signal, and the receiver's position is at the intersection of these spheres.\n\nTo determine an accurate position $(x, y, z)$ and synchronize the receiver’s clock, at least four satellites are required. The system of nonlinear equations representing the sphere intersections can be formulated as:\n\n$$\nr_i(x, y, z, d) = \\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} - c(t_i - d) = 0\n$$\n\nwhere $d$ is a clock correction factor for the receiver. Solving this system reveals both the receiver’s coordinates and the corrected clock time.\n\nHowever, the system faces challenges due to:\n\n1. **Receiver Clock Inaccuracy**: Affordable GPS receivers lack the precision of satellite atomic clocks, necessitating the inclusion of $d$ in the equations.\n2. **Ill-Conditioning**: The system becomes sensitive to errors when satellites are clustered close together in the sky.\n3. **Environmental Factors**: Signal transmission speed is affected by atmospheric interference and obstacles, introducing further inaccuracies.\n\nTo address these challenges:\n\n- **Numerical Root-Finding Methods** (e.g., Newton-Krylov, Gauss-Newton) iteratively solve the equations but can struggle with sensitivity to initial guesses and ill-conditioning.\n- **Error Analysis** evaluates the system's sensitivity to input timing errors, quantified through the **Error Magnification Factor (EMF)**, which assesses the impact of small changes in signal timing on positional accuracy.\n\nBy leveraging precise satellite positions and signal timing data, this system provides accurate navigation but requires advanced mathematical techniques to manage inherent nonlinearities and ensure robustness. This report focuses on exploring and solving the GPS positioning problem through numerical and analytical approaches, providing insights into accuracy, stability, and efficiency.\n\n# **Numerical Root-Finding Approach to GPS Positioning**\n\n## **Objective**\n\nThe objective of this study is to calculate the position of a GPS receiver $(x, y, z)$ and correct the receiver's clock bias $d$ by solving a system of nonlinear equations. These equations model the distance between the receiver and multiple satellites based on signal travel times. The numerical solution relies on iterative root-finding methods to achieve high accuracy.\n\n## **Background**\n\nIn a GPS system, the position of a receiver is determined by measuring the time it takes for signals to travel from multiple satellites. The propagation time, when multiplied by the speed of light $c$, provides the distance between the satellite and the receiver. Mathematically, the relationship between the receiver's unknown position $(x, y, z)$ and the clock correction $d$ is expressed as a system of nonlinear equations:\n\n$$\n\\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} = c(t_i - d), \\quad i = 1, 2, 3, 4\n$$\n\nWhere:\n\n- $(A_i, B_i, C_i)$ are the known satellite positions.\n- $t_i$ are the measured signal travel times.\n- $c \\approx 299,792.458 \\, \\text{km/s}$ is the speed of light.\n- $(x, y, z)$ are the unknown receiver coordinates.\n- $d$ is the receiver clock correction.\n\nEach equation corresponds to a sphere centered at the satellite's position, with the radius equal to the computed distance. The receiver's position lies at the intersection of these spheres. The inclusion of $d$ accounts for the clock bias in the receiver, which is less precise than the atomic clocks onboard GPS satellites.\n\n## **Methodology**\n\nA numerical root-finding approach is employed to solve this system of nonlinear equations. Specifically, Python's `fsolve` function from the `scipy.optimize` library is utilized. This method iteratively refines estimates for $(x, y, z, d)$ until the residuals—the differences between the measured and calculated distances—are minimized.\n\n### **Formulation of the Problem**\n\nThe system of equations is reformulated as residual functions $f_i$, where each function evaluates to zero when the system is satisfied:\n\n$$\nf_i(x, y, z, d) = \\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} - c(t_i - d), \\quad i = 1, 2, 3, 4\n$$\n\nThe root-finding process involves solving for $(x, y, z, d)$ such that all $f_i(x, y, z, d) = 0$.\n\n### **Numerical Solution**\n\nThe computational steps are as follows:\n\n1. **Input Data:** Known satellite positions $(A_i, B_i, C_i)$ and signal travel times $t_i$ are provided as inputs, along with the speed of light $c$.\n2. **Initial Guess:** A starting point of $(x_0, y_0, z_0) = (0, 0, 6370)$ km is assumed, placing the receiver near the Earth's surface. The initial clock correction is set to $d_0 = 0$.\n3. **Iterative Solver:** The `fsolve` function iteratively adjusts $(x, y, z, d)$ to minimize the residuals $f_i$. The algorithm terminates when all residuals approach zero, indicating convergence to a solution.\n\nThe implementation was tested using the following dataset:\n\n- Satellite positions:\n\n  - $(15,600, 7,540, 20,140)$\n  - $(18,760, 2,750, 18,610)$\n  - $(17,610, 14,630, 13,480)$\n  - $(19,170, 610, 18,390)$\n\n- Signal travel times:\n  $$\n  t = [0.07074, 0.07220, 0.07690, 0.07242] \\, \\text{(in seconds)}\n  $$\n\n::: {.callout-tip}\n\n### Accompanying Code\n\nThe [**accompanying code implementation**](./rc04-code.html) defines the residual function, applies the `fsolve` solver, and outputs the computed results.\n:::\n\n## **Results**\n\nThe numerical root-finding method produced the following results:\n\n- **Receiver Position (in km):**\n  $$\n  (x, y, z) = (-41.77271, -16.78919, 6370.0596)\n  $$\n- **Clock Correction (in seconds):**\n  $$\n  d = -3.201566 \\times 10^{-3}\n  $$\n\nThese values were verified against expected results, confirming the accuracy of the numerical solution. The computed receiver position aligns with the Earth's surface, and the clock correction accounts for the slight bias in the receiver's timing.\n\n## **Limitations**\n\nWhile the numerical root-finding approach proved effective, several limitations should be noted:\n\n1. **Sensitivity to Ill-Conditioning:** The system may become ill-conditioned when satellite positions are clustered, amplifying numerical errors and reducing accuracy.\n2. **Dependence on Initial Guesses:** Poor initial guesses can lead to non-convergence or convergence to an incorrect solution.\n3. **Computational Cost:** Iterative methods like `fsolve` require multiple evaluations of the residuals, making them computationally expensive for real-time applications.\n4. **Lack of Analytical Insights:** The numerical solution provides no explicit relationships between the variables, limiting its use for sensitivity analysis or theoretical exploration.\n\n## **Motivation for an Improved Approach**\n\nThe limitations of the numerical root-finding method highlight the need for a more robust and efficient solution. Specifically:\n\n- A method that avoids iterative guesswork.\n- Improved handling of ill-conditioned systems.\n- A more **analytical approach** that isolates variables and reduces the problem complexity.\n\nTo address these concerns, the next section introduces a **determinant-based analytical approach**. This method linearizes the system of equations, isolates variables explicitly, and reduces the problem to solving a single quadratic equation for the clock correction $d$. It offers both computational efficiency and greater stability, making it well-suited for real-time GPS positioning.\n\n## **Conclusion**\n\nThe numerical root-finding approach provides an approximate solution to the GPS equations but is limited by its sensitivity, inefficiency, and lack of robustness. These shortcomings motivate the need for an improved analytical method, which will be explored in the following section.\n\n# **Determinant-Based Analytical Approach to GPS Positioning**\n\n## **Objective**\n\nThe objective of this section is to solve the GPS equations **analytically** using a **determinant-based approach**. Unlike numerical root-finding methods, this analytical technique avoids iterative guesswork by isolating the variables $(x, y, z, d)$ explicitly. By systematically transforming the original nonlinear system into a more manageable linear form, this method ensures greater robustness, stability, and computational efficiency—critical for real-time or precision GPS applications.\n\nThe approach has been implemented in Python using the **SymPy** library to symbolically manipulate the equations, solve the system, and isolate the unknowns step-by-step.\n\n## **Problem Formulation**\n\nThe GPS receiver’s position $(x, y, z)$ and clock offset $d$ are determined from four satellite equations of the form:\n\n$$\n\\sqrt{(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2} = c(t_i - d), \\quad i = 1, 2, 3, 4\n$$\n\nHere:\n\n- $(A_i, B_i, C_i)$ are known satellite coordinates.\n- $t_i$ are measured signal travel times.\n- $c \\approx 299792.458\\,\\text{km/s}$ is the speed of light.\n- $(x, y, z)$ and $d$ are the unknown receiver coordinates and clock correction.\n\nEach equation represents a sphere with the satellite at its center. The receiver lies at the intersection of these four spheres. However, the presence of square roots and the unknown $d$ makes the system inherently nonlinear and challenging to solve directly.\n\n## **Methodology**\n\n::: {.callout-tip}\n\n### Code Implementation\n\nThe solution process involves three key stages, all of which are implemented in the accompanying [Python code](./rc04-code.html).\n:::\n\n### **Reducing the Nonlinear System to a Linear Form**\n\nTo eliminate the square roots, we square each equation. After doing so, we have:\n\n$$\n(x - A_i)^2 + (y - B_i)^2 + (z - C_i)^2 = c^2(t_i - d)^2\n$$\n\nWe then **subtract the equations for satellites $i=2,3,4$ from the equation for $i=1$**. This subtraction removes the $x^2 + y^2 + z^2$ terms and results in three linear equations in the four unknowns $x, y, z, d$:\n\n$$\nx u_{x}^{(j)} + y u_{y}^{(j)} + z u_{z}^{(j)} + d u_{d}^{(j)} + w^{(j)} = 0,\\quad j=1,2,3\n$$\n\nwhere $u_x^{(j)}, u_y^{(j)}, u_z^{(j)}, u_d^{(j)}, w^{(j)}$ are constants determined by the satellite positions and travel times.\n\nAt this point, we have **three linear equations** with **four unknowns**:\n\n$$\nx u_{x1} + y u_{y1} + z u_{z1} + d u_{d1} + w_1 = 0\n$$\n\n$$\nx u_{x2} + y u_{y2} + z u_{z2} + d u_{d2} + w_2 = 0\n$$\n\n$$\nx u_{x3} + y u_{y3} + z u_{z3} + d u_{d3} + w_3 = 0\n$$\n\n::: {.callout-tip}\n\n### Accompanying Code\n\nIn the accompanying code, this system of equations is constructed symbolically using **SymPy**, with the `simplify()` function applied to ensure clarity and precision in the linearized expressions.\n:::\n\n#### **Why Solve for the Variables in Terms of $d$?**\n\n---\n\nWith three linear equations and four unknowns, the system is underdetermined. We cannot directly solve for all four variables at once. To proceed, we:\n\n- Treat $d$ as a parameter.\n- Express $x, y, z$ as linear functions of $d$:\n\n  $$\n  x = f_x(d), \\quad y = f_y(d), \\quad z = f_z(d)\n  $$\n\nOnce $x, y, z$ are known in terms of $d$, we substitute these functions back into one of the original nonlinear equations. This will yield a **single quadratic equation in $d$**. Solving that quadratic equation gives us $d$. With $d$ in hand, we easily find $x, y, z$.\n\nThis approach reduces the complexity: instead of trying to solve four nonlinear equations simultaneously, we simplify the problem to solving one quadratic equation after isolating variables in terms of $d$.\n\n#### **Introducing the Determinant Equation**\n\n---\n\nTo isolate $x, y, z$ in terms of $d$, we use a **determinant-based approach**. Determinants are a powerful linear algebra tool. By arranging our linear equations in a matrix form and considering certain determinants, we can:\n\n- Identify linear dependencies,\n- Isolate one variable at a time,\n- Avoid ambiguity and instability.\n\nThe idea is to construct a determinant from the system of equations and carefully manipulate it so that one variable (e.g., $x$) can be extracted in terms of $y, z, d$ and constants. We then repeat or apply a similar reasoning for $y$ and $z$.\n\n### **Isolating $x$ in Terms of $d$ Using the Determinant**\n\n**Step-by-Step for $x$:**\n\n1. **Set Up the Determinant:**\n\n   Consider a matrix formed from the coefficient vectors $\\mathbf{u_x}, \\mathbf{u_y}, \\mathbf{u_z}, \\mathbf{u_d}, \\mathbf{w}$. A key construction is:\n\n   $$\n    \\det[\\mathbf{u_y} \\mid \\mathbf{u_z} \\mid x\\mathbf{u_x} + y\\mathbf{u_y} + z\\mathbf{u_z} + d\\mathbf{u_d} + \\mathbf{w}] = 0\n   $$\n\n   This determinant equals zero because if $-\\mathbf{w}$ lies in the span of the other vectors, the system is consistent. Expanding this determinant along the third column will separate terms involving $x, y, z, d$.\n\n   $$\n   \\text{det} \\begin{bmatrix}\n   u_{y1} & u_{z1} & x u_{x1} + y u_{y1} + z u_{z1} + d u_{d1} + w_1 \\\\\n   u_{y2} & u_{z2} & x u_{x2} + y u_{y2} + z u_{z2} + d u_{d2} + w_2 \\\\\n   u_{y3} & u_{z3} & x u_{x3} + y u_{y3} + z u_{z3} + d u_{d3} + w_3\n   \\end{bmatrix} = 0\n   $$\n\n2. **Expand the Determinant**:  \n   Expanding along the third column gives:\n\n   $$\n   \\text{det}[\\dots] = (x u_{x1} + y u_{y1} + z u_{z1} + d u_{d1} + w_1) \\cdot \\text{det} \\begin{bmatrix}\n   u_{y2} & u_{z2} \\\\\n   u_{y3} & u_{z3}\n   \\end{bmatrix}\n   $$\n\n   $$\n   - (x u_{x2} + y u_{y2} + z u_{z2} + d u_{d2} + w_2) \\cdot \\text{det} \\begin{bmatrix}\n   u_{y1} & u_{z1} \\\\\n   u_{y3} & u_{z3}\n   \\end{bmatrix}\n   $$\n\n   $$\n   + (x u_{x3} + y u_{y3} + z u_{z3} + d u_{d3} + w_3) \\cdot \\text{det} \\begin{bmatrix}\n   u_{y1} & u_{z1} \\\\\n   u_{y2} & u_{z2}\n   \\end{bmatrix}\n   $$\n\n3. **Group Terms Involving $x, y, z, d$**:  \n   Collect coefficients for each variable. For example for $x$, the coefficient $C_x$ is:\n\n   $$\n   C_x = u_{x1} \\cdot \\text{det} \\begin{bmatrix}\n   u_{y2} & u_{z2} \\\\\n   u_{y3} & u_{z3}\n   \\end{bmatrix}\n   - u_{x2} \\cdot \\text{det} \\begin{bmatrix}\n   u_{y1} & u_{z1} \\\\\n   u_{y3} & u_{z3}\n   \\end{bmatrix}\n   + u_{x3} \\cdot \\text{det} \\begin{bmatrix}\n   u_{y1} & u_{z1} \\\\\n   u_{y2} & u_{z2}\n   \\end{bmatrix}\n   $$\n\n   On expansion, you get an equation of the form:\n\n   $$\n   C_x x + C_y y + C_z z + C_d d + T = 0\n   $$\n\n   where $C_x, C_y, C_z, C_d, T$ are combinations of determinants and known constants derived from the satellite data.\n\n4. **Isolate $x$:**\n\n   To solve for $x$, rearrange the equation:\n\n   $$\n   x = -\\frac{C_y y + C_z z + C_d d + T}{C_x}\n   $$\n\n   However, at this stage, $x$ is still expressed in terms of $y, z, d$. To get $x$ purely in terms of $d$, you must similarly isolate $y$ and $z$ in terms of $d$.\n\n5. **Repeat for $y$ and $z$:**\n\n   By constructing similar determinant equations and performing analogous expansions, you isolate $y$ and $z$ as linear functions of $d$:\n\n   $$\n   y = f_y(d), \\quad z = f_z(d)\n   $$\n\n   Once $y(d)$ and $z(d)$ are known, substitute them back into the expression for $x$:\n\n   $$\n   x = f_x(d)\n   $$\n\n   Now all three spatial variables are functions of $d$:\n\n   $$\n   x = f_x(d), \\quad y = f_y(d), \\quad z = f_z(d)\n   $$\n\n::: {.callout-tip}\n\n### Accompanying Code\n\nThe accompanying code uses SymPy’s `linear_eq_to_matrix` to extract the coefficient matrix and split it into parts:\n\n- $A_{xyz}$: Coefficients for $x, y, z$,\n- $A_d$: Coefficients for $d$.\n\nThe resulting system is:\n\n$$\nA\\_{xyz} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} = -A_d d - \\mathbf{w}.\n$$\n\nSolving this system for $x$, $y$, and $z$ in terms of $d$ is achieved using the `LUsolve` function. The symbolic solutions $x(d)$, $y(d)$, and $z(d)$ are simplified and stored.\n:::\n\n### **Forming the Quadratic Equation in $d$**\n\nWith $x(d), y(d), z(d)$ established, we return to an original nonlinear equation. For example:\n\n$$\n\\sqrt{(x - A_1)^2 + (y - B_1)^2 + (z - C_1)^2} = c(t_1 - d)\n$$\n\n- Substitute $x(d), y(d), z(d)$ into the left-hand side.\n- Square both sides to remove the square root.\n\nAfter simplification, you obtain a **quadratic equation in $d$**:\n\n$$\na d^2 + b d + c = 0\n$$\n\nSolving this quadratic equation using the quadratic formula:\n\n$$\nd = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n$$\n\nChoose the physically meaningful solution for $d$ (the one placing the receiver near Earth’s surface), then substitute $d$ back into $x(d), y(d), z(d)$ to find the final coordinates $(x, y, z)$.\n\n::: {.callout-tip}\n\n### Accompanying Code\n\n1. Once $x(d)$, $y(d)$, and $z(d)$ are known, they are substituted back into one of the original nonlinear equations (e.g., the first equation). This substitution is performed symbolically in the code using `subs()`.\n\n2. Simplifying the resulting equation produces a **quadratic equation in $d$**:\n\n$$\na d^2 + b d + c = 0.\n$$\n\n3. The coefficients of the quadratic equation are extracted using SymPy's `Poly` and `all_coeffs` functions. The quadratic formula is then applied to solve for $d$.\n\n4. Among the solutions for $d$, the physically meaningful (real and close to zero) solution is selected. This step is automated in the code by evaluating the solutions and filtering for real roots.\n\n5. The final values of $x$, $y$, and $z$ are computed by substituting the selected $d$ back into $x(d)$, $y(d)$, and $z(d)$.\n\n**Results**\n\nThe determinant-based analytical approach produces the following results:\n\n- **Receiver Position (in km):**\n  $$\n  (x, y, z) = (-41.77271, -16.78919, 6370.0596)\n  $$\n- **Clock Correction (in seconds):**\n  $$\n  d = -3.201566 \\times 10^{-3}.\n  $$\n\nThese results are consistent with the numerical solutions obtained in **numerical root-finding approach**, confirming the correctness of the analytical method.\n:::\n\n## **Conclusion**\n\nThis determinant-based analytical approach transforms the original nonlinear GPS equations into a linearized problem, uses determinants to isolate $x, y, z$ in terms of $d$, and ultimately reduces the entire system to solving a single quadratic equation in $d$.\n\n**Key Advantages:**\n\n- No iterative guesswork required, avoiding convergence issues.\n- More stable and robust, especially when satellites are poorly distributed.\n- Provides a closed-form, analytical solution, offering deeper insight and efficiency.\n\nBy following these steps—reducing to a linear system, isolating variables in terms of $d$ using determinants, and forming a single quadratic in $d$—we obtain a direct and reliable solution to the GPS positioning problem.\n\n# **Conditioning Analysis of the GPS System**\n\n## **Objective**\n\nThe objective of this section is to evaluate how the **conditioning** of the GPS system changes when the satellite positions are either **loosely distributed** or **tightly grouped**. Sensitivity to small errors in signal travel times $t_i$ is analyzed using the **Error Magnification Factor (EMF)**. By comparing EMF values for both configurations, we identify how satellite geometry impacts the robustness and stability of the GPS positioning system.\n\n## **Background**\n\n### **GPS Sensitivity and Conditioning**\n\nIn GPS systems, small timing errors $\\Delta t_i$ in the satellite signals can result in significant positional errors. These errors arise from the **ill-conditioning** of the system of equations, which occurs when satellite positions are geometrically clustered.\n\nThe system is analyzed by:\n\n1. **Introducing Perturbations**: A small timing error $\\Delta t_i \\approx 10^{-8} \\, \\text{s}$ (equivalent to $3 \\, \\text{meters}$) is applied to each signal.\n2. **Forward Error**: The resulting change in the computed position is measured as:\n   $$\n   \\|\\Delta x, \\Delta y, \\Delta z\\|_2 = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n   $$\n3. **Error Magnification Factor (EMF)**: The EMF quantifies the sensitivity of the system to perturbations:\n   $$\n   \\text{EMF} = \\frac{\\|\\Delta x, \\Delta y, \\Delta z\\|_2}{c \\, \\|\\Delta t_i\\|_2}\n   $$\n   A **higher EMF** indicates a poorly conditioned system.\n\n### **Satellite Geometry**\n\n- **Loosely Distributed Satellites**: Satellites are widely spaced across the sky, providing better geometric diversity. This reduces ill-conditioning and improves robustness.\n- **Tightly Grouped Satellites**: Satellites are close together (within 5% of one another in spherical coordinates), leading to **geometric correlation** and increased sensitivity to timing errors.\n\n## **Methodology**\n\n### **Steps to Solve**\n\nThe analysis was conducted as follows:\n\n1. **Satellite Position Generation**:\n\n   - Loosely distributed satellites were generated using diverse spherical coordinates ($\\phi$ and $\\theta$).\n   - Tightly grouped satellites were generated by restricting both $\\phi_i$ and $\\theta_i$ within 5% of one another.\n\n2. **Nominal and Perturbed Signal Times**:\n\n   - For both configurations, nominal signal travel times $t_i$ were calculated based on the range:\n     $$\n     R_i = \\sqrt{A_i^2 + B_i^2 + (C_i - 6370)^2}, \\quad t_i = d + \\frac{R_i}{c}\n     $$\n   - Each $t_i$ was perturbed by $10^{-8} \\, \\text{s}$, while other times were held constant.\n\n3. **Solve for Position**:\n\n   - The GPS equations were solved numerically using `fsolve` for both nominal and perturbed travel times.\n   - The positional error $\\|\\Delta x, \\Delta y, \\Delta z\\|_2$ was computed for each perturbation.\n\n4. **Calculate EMF**:  \n   The EMF was calculated using the formula:\n\n   $$\n   \\text{EMF} = \\frac{\\|\\Delta x, \\Delta y, \\Delta z\\|_2}{c \\, \\|\\Delta t_i\\|_2}\n   $$\n\n5. **Compare Results**:  \n   EMF values were compared for both the loosely distributed and tightly grouped satellite configurations.\n\n::: {.callout-tip}\n\n### **Accompanying Code**\n\nThe [accompanying code](./rc04-code.html) performs the following steps:\n\n1. **Generate Satellite Positions**:\n\n   - Loosely spaced satellites use diverse $\\phi$ and $\\theta$ values.\n   - Tightly grouped satellites have $\\phi$ and $\\theta$ within 5% of each other.\n\n2. **Calculate Ranges and Times**:  \n   Nominal ranges $R_i$ and travel times $t_i$ are computed.\n\n3. **Introduce Perturbations**:  \n   Each signal time $t_i$ is perturbed by $10^{-8} \\, \\text{s}$, and the GPS equations are solved numerically using `fsolve`.\n\n4. **Compute Forward Error and EMF**:\n\n   - The positional error is computed as the Euclidean distance between the nominal and perturbed positions.\n   - EMF values are calculated for each perturbation.\n\n5. **Comparison of Configurations**:  \n   EMF values for loosely and tightly grouped satellites are compared, and the maximum EMF is identified.\n\n:::\n\n## **Results**\n\nThe results of the EMF analysis for both satellite configurations are as follows:\n\n### **Loose Satellites**\n\n| Perturbation in $t_i$ | EMF Value |\n| --------------------- | --------- |\n| $t_1$                 | 2.207538  |\n| $t_2$                 | 2.828432  |\n| $t_3$                 | 2.856126  |\n| $t_4$                 | 2.203932  |\n\n**Maximum EMF**:\n\n$$\n\\text{EMF}_{\\text{max}} = 2.856126\n$$\n\n### **Tightly Grouped Satellites**\n\n| Perturbation in $t_i$ | EMF Value   |\n| --------------------- | ----------- |\n| $t_1$                 | 1553.480087 |\n| $t_2$                 | 2317.787515 |\n| $t_3$                 | 3402.498373 |\n| $t_4$                 | 466.068303  |\n\n**Maximum EMF**:\n\n$$\n\\text{EMF}_{\\text{max}} = 3402.498373\n$$\n\n### **Comparison**\n\n| Configuration        | EMF Range   | Maximum EMF | Sensitivity |\n| -------------------- | ----------- | ----------- | ----------- |\n| **Loose Satellites** | 2.2 to 2.8  | 2.856126    | Low         |\n| **Tightly Grouped**  | 466 to 3402 | 3402.498373 | Very High   |\n\n## **Interpretation**\n\nThe results demonstrate a clear relationship between satellite geometry and the conditioning of the GPS system:\n\n1. **Loose Satellites**:\n\n   - EMF values remain low (around 2–3), indicating that the system is **well-conditioned**.\n   - Perturbations in signal times result in small position errors due to the geometric diversity of the satellites.\n\n2. **Tightly Grouped Satellites**:\n   - EMF values increase dramatically (up to 3402), showing that the system becomes **ill-conditioned**.\n   - Small input errors are significantly amplified, leading to large position errors.\n   - This sensitivity arises from the satellites’ correlated geometry, where their signals cannot provide sufficient independent information.\n\n## **Conclusion**\n\nThis analysis highlights the critical role of satellite geometry in the conditioning of the GPS system:\n\n- Loosely distributed satellites provide better geometric diversity and robustness, resulting in lower EMF values and greater accuracy.\n- Tightly grouped satellites lead to poor conditioning, amplifying errors and making the system highly sensitive to small perturbations in signal travel times.\n\nTo ensure accurate and stable GPS positioning, it is essential to use satellites with diverse spatial distributions. This insight is particularly valuable for optimizing satellite selection algorithms in GPS receivers.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true,"caption":"See code"},"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../../styles.css"],"toc":true,"self-contained":true,"toc-depth":3,"number-sections":true,"html-math-method":"katex","embed-resources":true,"output-file":"rc04.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":{"light":"flatly","dark":"darkly"},"title":"REALITY CHECK 04","author":"Nathan Lunceford","preview":{"port":3000,"browser":true,"watch-inputs":true,"navigate":true},"page-layout":"full","toc-location":"right","number-depth":3,"code-summary":"Show Code","code-copy":"hover"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}