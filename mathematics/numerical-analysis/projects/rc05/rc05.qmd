---
title: 'REALITY CHECK 05'
author: 'Nathan Lunceford'
format:
  html:
    self-contained: true
    page-layout: full
    toc: true
    toc-depth: 1
    toc-location: left
    number-sections: false
    html-math-method: katex
    code-overflow: wrap
    code-copy: hover
    code-tools:
      source: false
      toggle: false
      caption: See code
execute:
  warning: false
  message: false
---

```{python}
#| label: libraries
#| include: false

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
from functools import lru_cache
import time
```

# **OVERVIEW**

The use of **Adaptive Quadrature** is essential for maintaining constant speed along a specific path. This is a requirement in fields like computer-aided manufacturing, robotics and animation. Smooth and controlled movement is crucial for accuracy, but achieving a constant speed along a curved or complex path is challenging. Dividing a path into equal time intervals does not ensure equal-distance segments because the path’s shape influences the distance covered.

To address this, numerical methods are employed to divide the path into equal arc-length segments, ensuring consistent movement. The process involves several key steps:

1. **Arc Length Measurement**: The total length of the path is calculated using parametric equations, accounting for all curves and directional changes. This measurement provides the foundation for precise segmentation.

2. **Mapping Path Position**: To locate a point at a given distance $s$ along the path, the corresponding parameter $t$ is determined using numerical methods like Bisection or Newton’s Method. This ensures precise mapping of arc-length positions to their parametric coordinates.
3. **Segmenting the Path**: The path is divided into segments of equal arc length, a process called equipartitioning. This segmentation ensures uniformity in the spacing of points along the path, regardless of its complexity or curvature.

4. **Smooth Traversal**: Animations or simulations often demonstrate the practical effects of this approach. By comparing movement at constant parameter speed with movement along equal arc-length segments, the benefits of consistent, controlled traversal become clear, showcasing smoother and more predictable motion.

# **PROBLEM 01**

---

### **Problem Statement**

Write a Python function that computes the arc length of the path $P$ from $t = 0$ to $t = s$ for a given $0 \leq s \leq 1$. The choice of numerical integration method is up to you.

The path $P$ is defined as:

$$
P = \begin{cases}
x(t) = 0.5 + 0.3t + 3.9t^2 - 4.7t^3 \\
y(t) = 1.5 + 0.3t + 0.9t^2 - 2.7t^3
\end{cases}
$$

### **Objective and Approach**

The objective is to calculate the arc length, or total distance, along the path defined by $x(t)$ and $y(t)$ as $t$ moves from 0 to $s$, where $s$ is between 0 and 1. The arc length is not simply the straight-line distance between the start and end points, as the path may curve or change direction.

To accurately determine the distance traveled along the path, the following arc length formula is used:

$$
\text{Arc length} = \int_{0}^{s} \sqrt{\left( \frac{dx}{dt} \right)^2 + \left( \frac{dy}{dt} \right)^2} \, dt
$$

### **Solution Steps**

1. **Define the Path Functions**: Create functions for $x(t)$ and $y(t)$ to represent the parametric path.
2. **Calculate Derivatives**: Calculate $\frac{dx}{dt}$ and $\frac{dy}{dt}$, representing the rates of change of $x$ and $y$ with respect to $t$.
3. **Define the Integrand**: Use the derivatives to compute $\sqrt{\left( \frac{dx}{dt} \right)^2 + \left( \frac{dy}{dt} \right)^2}$, which represents the instantaneous speed along the path.
4. **Integrate the Speed**: Integrate this instantaneous speed from $t = 0$ to $t = s$ to obtain the total arc length (distance traveled along the curve).

### **Solution Code**

The Python code below implements the above steps to calculate the arc length from $t = 0$ to a specified $t = s$ using numerical integration:

```{python}
#| echo: true
#| include: true

import numpy as np
from scipy.integrate import quad

# Define the functions for x(t) and y(t)
def x(t):
    return 0.5 + 0.3 * t + 3.9 * t**2 - 4.7 * t**3

def y(t):
    return 1.5 + 0.3 * t + 0.9 * t**2 - 2.7 * t**3

# Define the derivatives of x(t) and y(t)
def dx_dt(t):
    return 0.3 + 2 * 3.9 * t - 3 * 4.7 * t**2

def dy_dt(t):
    return 0.3 + 2 * 0.9 * t - 3 * 2.7 * t**2

# Define the integrand for the arc length
def integrand(t):
    return np.sqrt(dx_dt(t)**2 + dy_dt(t)**2)

# Function to compute the arc length from t=0 to t=s
def compute_arc_length(s):
    arc_length, _ = quad(integrand, 0, s)
    return arc_length
```

### **Explanation of Solution Components**

1. **Path Functions $x(t)$ and $y(t)$**: The functions $x(t)$ and $y(t)$ define the parametric equations for the path.
2. **Derivatives $dx/dt$ and $dy/dt$**: The functions `dx_dt` and `dy_dt` compute the derivatives of $x(t)$ and $y(t)$ with respect to $t$, representing the rate of change at each point along the path.
3. **Arc Length Integrand**: The `integrand` function calculates the instantaneous speed along the path by combining $dx/dt$ and $dy/dt$ using the Pythagorean theorem.
4. **Integration**: The `compute_arc_length` function uses numerical integration to compute the total arc length from $t = 0$ to $t = s$, giving the distance traveled along the curve.

### **Result and Observations**

This function successfully computes the arc length for any specified $s$, providing an accurate measure of the total distance traveled along the path up to that point. By integrating the instantaneous speed, this approach accounts for the curvature and direction changes of the path.

# **PROBLEM 02**

---

### **Problem Statement**

Write a program that, for any input $0 \leq s \leq 1$, finds the parameter $t^*(s)$ that is $s$ of the way along the path. In other words, the arc length from $t = 0$ to $t = t^*(s)$ divided by the arc length from $t = 0$ to $t = 1$ should be equal to $s$. Use the Bisection Method to locate the point $t^*(s)$ to three correct decimal places.

**Key Questions**:

- What function is being set to zero?
- What bracketing interval should be used to start the Bisection Method?

### **Objective and Approach**

The objective is to determine the parameter $t^*(s)$ such that the arc length from $t = 0$ to $t = t^*(s)$ represents a fraction $s$ (where $0 \leq s \leq 1$) of the total path length.

To accomplish this:

1. **Condition Definition**: Define the condition that the arc length from $t = 0$ to $t = t^*(s)$ divided by the total arc length (from $t = 0$ to $t = 1$) should be equal to $s$:

   $$
   \frac{\int_{0}^{t^*(s)} \sqrt{\left( \frac{dx}{dt} \right)^2 + \left( \frac{dy}{dt} \right)^2} \, dt}{\int_{0}^{1} \sqrt{\left( \frac{dx}{dt} \right)^2 + \left( \frac{dy}{dt} \right)^2} \, dt} = s
   $$

2. **Objective Function**: Rewrite this condition as $f(t) = 0$, where

   $$
   f(t) = \frac{\text{Arc length from } t = 0 \text{ to } t^*(s)}{\text{Total arc length}} - s
   $$

3. **Bisection Method**: Use the Bisection Method to find $t$ such that $f(t) = 0$, starting with an initial interval of \([0, 1]\) and achieving a precision of three decimal places.

### **Solution Code**

The Python code below implements the above approach using the Bisection Method to locate $t^*(s)$ for any input $s$:

```{python}
#| echo: true
#| include: true

# Total arc length from t=0 to t=1
total_arc_length = compute_arc_length(1)

# Objective function to solve for t^*(s)
def f(t, s):
    return compute_arc_length(t) / total_arc_length - s

# Bisection method to find t^*(s)
def find_t_star(s, tol=1e-3):
    a, b = 0, 1
    while (b - a) / 2 > tol:
        midpoint = (a + b) / 2
        if f(midpoint, s) == 0:
            return midpoint
        elif f(a, s) * f(midpoint, s) < 0:
            b = midpoint
        else:
            a = midpoint
    return (a + b) / 2

# Example usage
s = 0.5  # Example value for s (e.g., halfway along the path)
t_star = find_t_star(s)

```

### **Explanation of Solution Components**

1. **Objective Function $f(t, s)$**: This function calculates the difference between the actual fraction of the arc length from $t = 0$ to $t$ and the target fraction $s$. The goal is to find $t$ where this difference is zero, meaning the arc length up to $t$ matches the desired fraction $s$.
2. **Bisection Method**: The `find_t_star` function implements the Bisection Method to iteratively refine the interval until $f(t) = 0$ within a specified tolerance, ensuring $t^*(s)$ is accurate to three decimal places.

### **Result and Observations**

This solution accurately finds $t^*(s)$ for any input $s$, ensuring that the corresponding point on the path represents exactly $s$ of the total arc length. By using the Bisection Method, this approach achieves high precision even for paths with complex curves.

# **PROBLEM 03**

## **Path Equipartitioning by Arc Length**

### **Problem Statement**

Equipartition the path of Figure 5.6 into $n$ subpaths of equal length, for $n = 4$ and $n = 20$. Plot analogues of Figure 5.6, showing the equipartitions.

```{python}
#| echo: false
#| include: true
import numpy as np
import matplotlib.pyplot as plt

# Define the functions for x(t) and y(t)
def x(t):
    return 0.5 + 0.3 * t + 3.9 * t**2 - 4.7 * t**3

def y(t):
    return 1.5 + 0.3 * t + 0.9 * t**2 - 2.7 * t**3

# Define t values for labeled points
t_values = [0, 0.25, 0.5, 0.75, 1]
x_points = [x(t) for t in t_values]
y_points = [y(t) for t in t_values]
labels = ["$t = 0$", "$t = 1/4$", "$t = 1/2$", "$t = 3/4$", "$t = 1$"]

# Generate smooth curve for the path
t_vals = np.linspace(0, 1, 500)
x_vals = x(t_vals)
y_vals = y(t_vals)

# Create figure and axis
fig, ax = plt.subplots()

# Plot the path
ax.plot(x_vals, y_vals, color="#2196F3", linewidth=2)
ax.scatter(x_points, y_points, color="#2196F3", s=30, zorder=3)

# Add labels
for (px, py, label) in zip(x_points, y_points, labels):
    ax.text(px + 0.03, py + 0.1 , label, fontsize=8, ha='left')

# Style the plot
ax.axhline(0, color="black", linewidth=0.5)
ax.axvline(0, color="black", linewidth=0.5)
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_xlim(-1.5, 1.5)
ax.set_ylim(-0.5, 2.5)
ax.set_aspect('equal')
ax.set_xticks([-1, 0, 1])
ax.set_yticks([0, 1, 2])
ax.set_title("Figure 5.6: Parametrized curve given by Bézier spline.")
ax.grid(True)

# Show the plot
plt.show()

```

### **Objective and Approach**

The objective is to partition the path, defined by parametric equations $x(t)$ and $y(t)$, into segments of equal arc length for a specified $n$. This method is valuable in fields requiring consistent movement along a path, such as animation or robotics.

The approach includes the following steps:

1. **Calculate Total Arc Length**: Compute the total arc length from $t = 0$ to $t = 1$ using numerical integration, enabling calculation of the length of each segment.

   $$
   \text{Segment length} = \frac{\text{Total arc length}}{n}
   $$

2. **Locate Partition Points Using the Bisection Method**: For each segment $i$, use the Bisection Method to locate the parameter $t_i$ so that the arc length from $t = 0$ to $t = t_i$ equals $i \times \text{Segment length}$. This ensures equal arc lengths for each segment.

3. **Plot the Equipartitioned Path**: Calculate $x(t_i)$ and $y(t_i)$ at each partition point and plot for both $n = 4$ and $n = 20$, visualizing uniform segmentation.

### **Solution Code**

```{python}
#| label: p3
#| echo: true
#| include: true

# Bisection method to find t for a target arc length fraction
def bisection_find_t(target_length, tol=1e-8):
    a, b = 0, 1
    while (b - a) / 2 > tol:
        midpoint = (a + b) / 2
        if compute_arc_length(midpoint) == target_length:
            return midpoint
        elif compute_arc_length(midpoint) < target_length:
            a = midpoint
        else:
            b = midpoint
    return (a + b) / 2

# Equipartition function
def equipartition(n):
    partition_points = [0]
    total_length = compute_arc_length(1)
    segment_length = total_length / n
    for i in range(1, n):
        target_length = i * segment_length
        t_i = bisection_find_t(target_length)
        partition_points.append(t_i)
    partition_points.append(1)
    return partition_points

# Plot function for equipartitioned curve
def plot_styled_curve(n):
    plt.figure(figsize=(8, 8), facecolor='white')

    t_vals = np.linspace(0, 1, 500)
    x_vals = x(t_vals)
    y_vals = y(t_vals)

    key_points_t = equipartition(n)
    key_points_x = [x(t) for t in key_points_t]
    key_points_y = [y(t) for t in key_points_t]

    # Plot the curve with enhanced styling
    plt.plot(x_vals, y_vals, color="#2196F3", linewidth=2.5, zorder=3)
    plt.scatter(key_points_x, key_points_y, color="#1565C0", s=40, zorder=4)

    # Add grid with softer appearance
    plt.grid(True, linestyle='-', alpha=0.2, color='gray')
    plt.xticks(np.arange(-1, 1.5, 0.5))
    plt.yticks(np.arange(0, 2.5, 0.5))


    # Enhanced axis lines
    ax = plt.gca()
    ax.set_xticklabels(['' if x == 0 else str(x) for x in ax.get_xticks()])
    ax.set_yticklabels(['' if y == 0 else str(y) for y in ax.get_yticks()])

    ax.spines['left'].set_position('zero')
    ax.spines['bottom'].set_position('zero')
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_linewidth(1.5)
    ax.spines['bottom'].set_linewidth(1.5)

    # Enhance tick appearance
    plt.tick_params(axis='both', which='major', length=6, width=1, colors='black', direction='out')
    plt.tick_params(axis='both', which='minor', length=3, width=1, colors='black', direction='out')

    # Label positioning and styling
    ax.set_ylabel('y', rotation=0, labelpad=15, y=1.02, fontsize=12)
    ax.set_xlabel('x', x=1.02, fontsize=12)

    plt.xlim(-1.5, 1.5)
    plt.ylim(-0.5, 2)
    plt.gca().set_aspect('equal')

    plt.show()

```

#### Equipartitioned Curve with $n = 4$

```{python}
#| echo: false
#| include: true

plot_styled_curve(4)
```

#### Equipartitioned Curve with $n = 20$

```{python}
#| echo: false
#| include: true

plot_styled_curve(20)
```

### **Explanation of Solution Components**

1. **Arc Length Calculation**: The function `compute_arc_length(s)` uses numerical integration to compute the arc length from $t = 0$ to a given $t = s$.

2. **Bisection Method for Partitioning**: `bisection_find_t(target_length)` finds the parameter $t$ corresponding to a specific arc length, ensuring accurate partition points.

3. **Equipartition Function**: `equipartition(n)` calculates $t$-values for partitioning the path into $n$ equal arc-length segments.

4. **Visualization**: `plot_styled_curve(n)` generates a plot showing the path with points marking each partition.

### **Results and Observations**

The plots for $n = 4$ and $n = 20$ illustrate the uniform segmentation of the path into equal-length segments, confirming the effectiveness of the equipartitioning process. This approach achieves constant distances along the path, despite non-uniform parameter spacing.

### **Conclusion**

The solution effectively partitions the path into equal-length segments using numerical integration and the Bisection Method. This method can be further enhanced by employing Newton’s Method for faster convergence or adapting it to three-dimensional paths.

# **PROBLEM 04**

## **Path Equipartitioning Using Newton’s Method**

### **Problem Statement**

Replace the Bisection Method in Step 2 with Newton’s Method, and repeat Steps 2 and 3. What is the derivative needed? What is a good choice for the initial guess? Is computation time decreased by this replacement?

### **Objective and Approach**

1. **Objective**: Use Newton’s Method to locate each partition point $t_i$ along the path, ensuring equal arc-length segments for a specified number of partitions $n$. Newton’s Method is expected to offer faster convergence than the Bisection Method, especially when starting with a good initial guess.

2. **Required Derivative**: Newton’s Method requires the derivative of the arc length function with respect to $t$, which is simply the arc length integrand evaluated at $t$:

   $$
   f'(t) = \sqrt{\left( \frac{dx}{dt} \right)^2 + \left( \frac{dy}{dt} \right)^2}
   $$

3. **Initial Guess**: A reasonable initial guess for each $t_i$ is $t_i = \frac{i}{n}$, which provides a uniformly spaced initial estimate along $t$, aiding the convergence of Newton’s Method.

4. **Performance Comparison**: To evaluate if Newton’s Method reduces computation time, we will measure the time taken by both the Bisection and Newton’s methods to achieve the same accuracy.

#### **Why $t_i = \frac{i}{n}$ is a Good Initial Guess**

- **Uniform Parameter Distribution**: The parameter $t$ varies between 0 and 1 (or the specified range of $t$), and $\frac{i}{n}$ provides evenly spaced points within this interval. This ensures that the initial guess is distributed consistently across the parameter space.
- **Proximity to the True Solution**: For smooth and "well-behaved" curves, the true $t_i$ values for equal arc-length segments are often near $\frac{i}{n}$. This proximity ensures that Newton’s Method starts "in the ballpark" of the correct value.
- **Simplicity and Efficiency**: Computing $\frac{i}{n}$ is computationally trivial and requires no extra effort. This simplicity makes it a practical choice compared to complex initialization schemes.
- **Improved Convergence**: Starting close to the actual solution allows Newton’s Method to converge quadratically, reducing the number of iterations needed to achieve the desired accuracy.

### **Solution Code**

The following Python code implements Newton’s Method to find partition points and compares its performance with the Bisection Method.

```{python}
#| label: p4
#| echo: true
#| include: true

import time

# Newton's Method to find t for a target arc length
def newton_find_t(target_length, initial_guess, tol=1e-8, max_iter=100):
    t = initial_guess
    for _ in range(max_iter):
        f_t = compute_arc_length(t) - target_length
        f_prime_t = integrand(t)
        if abs(f_t) < tol:
            return t
        t -= f_t / f_prime_t  # Update t
    return t

# Compare performance of Bisection and Newton's methods
def compare_performance(target_length):
    start_time_bisection = time.time()
    bisection_result = bisection_find_t(target_length)
    bisection_time = time.time() - start_time_bisection

    start_time_newton = time.time()
    newton_result = newton_find_t(target_length, initial_guess=0.5)
    newton_time = time.time() - start_time_newton

    print(f"Bisection Method Result: {bisection_result:.9f} Time: {bisection_time:.9f} seconds")
    print(f"Newton's Method Result: {newton_result:.9f} Time: {newton_time:.9f} seconds")

# Example target length (e.g., half the arc length)
total_length = compute_arc_length(1)
compare_performance(total_length / 2)
```

### **Explanation of Solution Components**

1. **Newton’s Method Implementation**: The `newton_find_t` function applies Newton’s Method to locate the parameter $t$ for a given arc length. It iteratively refines $t$ by calculating $f(t)$ and $f'(t)$, adjusting $t$ based on the result.

2. **Performance Comparison**: The `compare_performance` function compares the time taken by Bisection and Newton’s methods to find the target $t$-value. This illustrates the efficiency difference between the two methods.

### **Results and Observations**

- **Performance Gain**: Newton’s Method generally converges faster than the Bisection Method due to its quadratic convergence rate.
- **Accuracy**: With an appropriately chosen initial guess, Newton’s Method efficiently reaches an accurate solution within fewer iterations.

### **Conclusion**

Newton’s Method provides a more efficient approach for finding the partition points, particularly when an initial guess is available. This reduction in computation time makes it suitable for tasks requiring high precision and quick convergence, such as real-time applications in path traversal and equipartitioning. Future explorations could involve further optimizations by dynamically refining initial guesses based on prior calculations.

# **PROBLEM 05**

## **Path Animation at Original and Constant Speed**

### **Problem Statement**

Use Python animation commands to demonstrate traveling along the path in two ways:

1. At the original speed, based on parameter $t$ for $0 \leq t \leq 1$, which results in non-uniform speed along the path.
2. At a constant speed using $t^*(s)$ for $0 \leq s \leq 1$, where the path is re-parameterized to maintain equal arc-length segments.

### **Objective and Approach**

1. **Objective**: To visualize the difference between non-uniform and constant-speed traversal along a path.

   - **Original Speed**: Animate movement along the path based on evenly spaced $t$-values, resulting in variable speed.
   - **Constant Speed**: Animate movement along the path with equal arc-length segments by using equipartition points $t^*(s)$.

2. **Approach**:
   - **Original Speed Animation**: Use uniformly spaced $t$-values from $t = 0$ to $t = 1$ to display the natural parameter-based speed.
   - **Constant Speed Animation**: Use the previously calculated equipartition points $t^*(s)$ to animate movement along equal arc-length segments, ensuring a uniform speed.

### **Solution Code**

The following Python code generates both animations, showing the path traversal at original and constant speeds.

```python
import matplotlib.animation as animation

def animate_path():
    fig = plt.figure(figsize=(16, 8), facecolor='white')

    ax1 = fig.add_subplot(121)
    ax2 = fig.add_subplot(122)

    # Generate data for original and constant speed
    t_values_original_speed = np.linspace(0, 1, 25)
    x_vals_original_speed = x(t_values_original_speed)
    y_vals_original_speed = y(t_values_original_speed)

    t_values_constant_speed = equipartition(25)
    x_vals_constant_speed = [x(t) for t in t_values_constant_speed]
    y_vals_constant_speed = [y(t) for t in t_values_constant_speed]

    # Enhanced styling function for subplots
    def style_subplot(ax, title):
        ax.grid(True, linestyle='-', alpha=0.2, color='gray')
        ax.set_xlim(-1.5, 1.5)
        ax.set_ylim(-0.5, 2)
        ax.set_xticks(np.arange(-1, 1.5, 0.5))
        ax.set_yticks(np.arange(0, 2.5, 0.5))
        ax.set_aspect('equal')
        ax.set_xticklabels(['' if x == 0 else str(x) for x in ax.get_xticks()])
        ax.set_yticklabels(['' if y == 0 else str(y) for y in ax.get_yticks()])


        # Enhanced axis lines
        ax.spines['left'].set_position('zero')
        ax.spines['bottom'].set_position('zero')
        ax.spines['right'].set_visible(False)
        ax.spines['top'].set_visible(False)
        ax.spines['left'].set_linewidth(1.5)
        ax.spines['bottom'].set_linewidth(1.5)

        # Enhanced ticks
        ax.tick_params(axis='both', which='major', length=6, width=1, colors='black', direction='out')
        ax.tick_params(axis='both', which='minor', length=3, width=1, colors='black', direction='out')

        ax.set_title(title, pad=20, fontsize=12, fontweight='bold')

    # Configure first subplot
    ax1.plot(x_vals_original_speed, y_vals_original_speed, color="#2196F3", linewidth=2.5, zorder=3)
    original_point, = ax1.plot([], [], 'o', color="#1565C0", markersize=8, zorder=4)
    style_subplot(ax1, "Original Speed")

    # Configure second subplot
    ax2.plot(x_vals_constant_speed, y_vals_constant_speed, color="#2196F3", linewidth=2.5, zorder=3)
    constant_point, = ax2.plot([], [], 'go',  markersize=8, zorder=4)
    style_subplot(ax2, "Constant Speed")

    plt.tight_layout()

    def update_original(fnum):
        original_point.set_data(x_vals_original_speed[:fnum], y_vals_original_speed[:fnum])
        return original_point,

    def update_constant(fnum):
        constant_point.set_data(x_vals_constant_speed[:fnum], y_vals_constant_speed[:fnum])
        return constant_point,

    num_frames = len(x_vals_original_speed)
    ani = animation.FuncAnimation(fig, lambda fnum: update_original(fnum) + update_constant(fnum),
                                frames=num_frames, interval=200, blit=True)
    ani.save('combined_animation.mp4', writer='ffmpeg')
```

<div style="display: flex; justify-content: center; margin-top: 1rem;">
  <video controls autoplay loop muted width="800">
    <source src="combined_animation.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>
</div>

### **Explanation of Solution Components**

1. **Animation Setup**:

   - **Original Speed**: Uses evenly spaced $t$-values from 0 to 1, resulting in non-uniform movement along the path.
   - **Constant Speed**: Uses equipartition points $t^*(s)$, calculated to ensure each segment has the same arc length, resulting in uniform movement.

2. **Animation Update Functions**: Each animation frame updates the moving point on the respective path for both original and constant speeds.

### **Results and Observations**

The two animations effectively demonstrate the difference between moving at a variable speed (based on $t$) and moving at a constant speed along equal arc-length segments. By using equipartition points, the constant-speed animation shows smooth, uniform movement, which can be advantageous for applications requiring consistent traversal rates.

# **PROBLEM 06**

## **Experimenting with Equipartitioning on a Custom Path**

### **Problem Statement**

Experiment with equipartitioning a path of your choice. Choose a path defined by parametric equations, partition it into equal arc-length segments, and animate the traversal as demonstrated in Problem 5.

#### **Chosen Equation:**

$$
x(t) = 0.4 \sin(3t + \frac{\pi}{2}) + 0.5
$$

$$
y(t) = 0.3 \sin(4t) + 0.5
$$

### **Objective and Approach**

1. **Objective**: To apply equipartitioning to the specified path, dividing it into segments of equal arc length and visualizing the traversal at constant speed.
2. **Approach**:
   - **Path Definition**: Define $x(t)$ and $y(t)$ based on the given equations.
   - **Equipartitioning**: Use numerical integration and Newton's Method to divide the path into equal-length segments.
   - **Animation**: Animate the traversal of the path at a constant speed along the equal arc-length segments and compare it with traversal at the original, parameter-based speed.

### **Solution Code**

The Python code below calculates the equipartitioned segments and animates traversal along the path:

```python
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from scipy.integrate import quad

# Parameters for the curve
A = 0.4
a = 3
f = np.pi / 2
c = 0.5
B = 0.3
b = 4
D = 0.5

# Maximum value of t for one full loop
t_max = 2 * np.pi

# Define the functions for x(t) and y(t)
def x(t):
    return A * np.sin(a * t + f) + c

def y(t):
    return B * np.sin(b * t) + D

# Derivatives of x(t) and y(t) for arc length calculation
def dx_dt(t):
    return A * a * np.cos(a * t + f)

def dy_dt(t):
    return B * b * np.cos(b * t)

# Integrand for arc length calculation
def integrand(t):
    return np.sqrt(dx_dt(t)**2 + dy_dt(t)**2)

# Compute arc length using numerical integration
def compute_arc_length(s):
    arc_length, _ = quad(integrand, 0, s)
    return arc_length

# Equipartition function to divide path into equal arc-length segments
def equipartition(n):
    total_length = compute_arc_length(2 * np.pi)
    segment_length = total_length / n
    partition_points = [0]
    for i in range(1, n):
        target_length = i * segment_length
        partition_points.append(find_t_for_length(target_length, partition_points[-1]))
    partition_points.append(2 * np.pi)
    return partition_points

# Find parameter t for a given arc length using Newton's Method
def find_t_for_length(target_length, initial_guess=0, tol=1e-8, max_iter=100):
    t = initial_guess
    for _ in range(max_iter):
        f_t = compute_arc_length(t) - target_length
        f_prime_t = integrand(t)
        if abs(f_t) < tol:
            return t
        t -= f_t / f_prime_t
        t = max(0, min(2 * np.pi, t))
    return t


# Data for animations
n_points = 200
t_values_original = np.linspace(0, 2 * np.pi, n_points)
x_original = x(t_values_original)
y_original = y(t_values_original)

t_values_constant = equipartition(n_points)
x_constant = [x(t) for t in t_values_constant]
y_constant = [y(t) for t in t_values_constant]

# Set up the figure for side-by-side animation
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))

# Original speed plot
ax1.plot(x_original, y_original, color="#2196F3", linewidth=2)
point1, = ax1.plot([], [], 'o', color="#1565C0")
ax1.set_title("Original Speed")
ax1.set_xlim(0, 1)
ax1.set_ylim(0, 1)
ax1.set_aspect('equal')
ax1.grid(True, linestyle='-', alpha=0.2, color='gray')

# Constant speed plot
ax2.plot(x_constant, y_constant, color="#2196F3", linewidth=2)
point2, = ax2.plot([], [], 'go')
ax2.set_title("Constant Speed")
ax2.set_xlim(0, 1)
ax2.set_ylim(0, 1)
ax2.set_aspect('equal')
ax2.grid(True, linestyle='-', alpha=0.2, color='gray')

# Update functions for each animation
def update_original(frame):
    point1.set_data(x_original[:frame], y_original[:frame])
    return point1,

def update_constant(frame):
    point2.set_data(x_constant[:frame], y_constant[:frame])
    return point2,

# Combine animations into one
num_frames = len(x_original)
ani = animation.FuncAnimation(
    fig,
    lambda frame: update_original(frame) + update_constant(frame),
    frames=num_frames,
    interval=100,
    blit=True
)

# Save animation as MP4
ani.save("custom_path_animation.mp4", writer="ffmpeg")
```

<div style="display: flex; justify-content: center; margin-top: 1rem;">
  <video controls autoplay loop muted width="800">
    <source src="custom_path_animation.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>
</div>

### **Explanation of Solution Components**

1. **Path Definition**: The parametric equations for $x(t) = 0.4 \sin(3t + \frac{\pi}{2}) + 0.5$ and $y(t) = 0.3 \sin(4t) + 0.5$ define a periodic curve with sinusoidal behavior, creating a visually interesting pattern with symmetric, tight curves.
2. **Arc Length Calculation**: The function `compute_arc_length` integrates the instantaneous speed along the curve (using derivatives $dx/dt$ and $dy/dt$) over the interval [0, s] to determine the total distance traveled up to a given $s$.
3. **Equipartitioning**: The `equipartition` function divides the path into $n$ segments of equal arc length by calculating the target length of each segment and using Newton's Method to determine $t$ values corresponding to each target segment length. This ensures the segments are evenly spaced along the curve.
4. **Animation**: The `animate_path` function generates side-by-side animations of path traversal at original speed (based on parameter $t$) and constant speed (based on equal arc-length segments).

### **Results and Observations**

In the animation:

- **Original Speed**: The left animation shows traversal based on equally spaced $t$ values, resulting in variable speed along the curve. The point moves faster along straighter sections and slows down significantly in tighter curves.
- **Constant Speed**: The right animation demonstrates traversal at a constant speed along equal arc-length segments. This movement is smoother and consistent, highlighting how equipartitioning ensures a steady traversal rate even along complex paths.

### **Conclusion**

This exercise illustrates the benefits of equipartitioning a path into equal arc-length segments for applications that require consistent speed. By reparameterizing the curve to maintain constant speed, we can avoid the variable movement speed that results from a simple, evenly spaced parameter $t$. This method has potential applications in animation, robotics, and automated manufacturing, where uniform movement along a path with varying curvature is essential.

# **CODE**

The code above can be organized into a `ParametricCurve` class to improve structure and follow best practices. This class combines all the key methods, such as arc length computation, root-finding, and equipartitioning, into a clear and reusable design.

```python
class ParametricCurve:
    def __init__(self, x_func, y_func, dx_dt_func, dy_dt_func, t_min=0, t_max=1):
        self.x = x_func
        self.y = y_func
        self.dx_dt = dx_dt_func
        self.dy_dt = dy_dt_func
        self.t_min = t_min
        self.t_max = t_max

    def integrand(self, t):
        return np.sqrt(self.dx_dt(t)**2 + self.dy_dt(t)**2)

    @lru_cache(maxsize=None)
    def compute_arc_length(self, s):
        arc_length, _ = quad(self.integrand, self.t_min, s)
        return arc_length

    def total_length(self):
        return self.compute_arc_length(self.t_max)

    def newton_find_t(self, target_length, initial_guess=None, tol=1e-8, max_iter=100):
        if initial_guess is None:
            initial_guess = (self.t_min + self.t_max) / 2
        t = initial_guess
        for _ in range(max_iter):
            f_t = self.compute_arc_length(t) - target_length
            f_prime_t = self.integrand(t)
            if abs(f_t) < tol:
                return t
            if f_prime_t == 0:
                raise ZeroDivisionError("Derivative zero encountered in Newton's method.")
            t -= f_t / f_prime_t
            t = max(self.t_min, min(self.t_max, t))
        raise RuntimeError("Newton's method did not converge.")

    def bisection_find_t(self, target_length, a=None, b=None, tol=1e-8, max_iter=100):
        if a is None:
            a = self.t_min
        if b is None:
            b = self.t_max
        fa = self.compute_arc_length(a) - target_length
        fb = self.compute_arc_length(b) - target_length
        if fa * fb > 0:
            raise ValueError("Bisection method fails: function has same signs at interval endpoints.")
        for _ in range(max_iter):
            t = (a + b) / 2
            f_t = self.compute_arc_length(t) - target_length
            if abs(f_t) < tol:
                return t
            if fa * f_t < 0:
                b = t
                fb = f_t
            else:
                a = t
                fa = f_t
        return t

    def equipartition(self, n, method='newton'):
        total_length = self.total_length()
        segment_length = total_length / n
        partition_points = [self.t_min]
        for i in range(1, n):
            target_length = i * segment_length
            initial_guess = partition_points[-1]
            if method == 'newton':
                t_i = self.newton_find_t(target_length, initial_guess)
            elif method == 'bisection':
                t_i = self.bisection_find_t(target_length, a=initial_guess)
            else:
                raise ValueError("Method must be 'newton' or 'bisection'.")
            partition_points.append(t_i)
        partition_points.append(self.t_max)
        return partition_points
```

### **Usage Example**

To use the `ParametricCurve` class for problem 1-6:

```python
# Define the first curve
def x1(t):
    return 0.5 + 0.3 * t + 3.9 * t**2 - 4.7 * t**3

def y1(t):
    return 1.5 + 0.3 * t + 0.9 * t**2 - 2.7 * t**3

def dx1_dt(t):
    return 0.3 + 2 * 3.9 * t - 3 * 4.7 * t**2

def dy1_dt(t):
    return 0.3 + 2 * 0.9 * t - 3 * 2.7 * t**2

# Create an instance of ParametricCurve for the first curve
curve1 = ParametricCurve(x1, y1, dx1_dt, dy1_dt, t_min=0, t_max=1)

# Define the second curve
A = 0.4
a = 3
f = np.pi / 2
c = 0.5
B = 0.3
b = 4
D = 0.5
t_max2 = 2 * np.pi

def x2(t):
    return A * np.sin(a * t + f) + c

def y2(t):
    return B * np.sin(b * t) + D

def dx2_dt(t):
    return A * a * np.cos(a * t + f)

def dy2_dt(t):
    return B * b * np.cos(b * t)

# Create an instance of ParametricCurve for the second curve
curve2 = ParametricCurve(x2, y2, dx2_dt, dy2_dt, t_min=0, t_max=t_max2)

def style_plot(ax, x_limits, y_limits, adjust_tick_labels=True):

    ax.grid(True, linestyle='-', alpha=0.2, color='gray')
    ax.set_xticks(np.arange(x_limits[0], x_limits[1] + 0.5, 0.5))
    ax.set_yticks(np.arange(y_limits[0], y_limits[1] + 0.5, 0.5))

    if adjust_tick_labels:
        ax.set_xticklabels(['' if x == 0 else f"{x:.1f}" for x in ax.get_xticks()])
        ax.set_yticklabels(['' if y == 0 else f"{y:.1f}" for y in ax.get_yticks()])

    ax.spines['left'].set_position('zero')
    ax.spines['bottom'].set_position('zero')
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.spines['left'].set_linewidth(1.5)
    ax.spines['bottom'].set_linewidth(1.5)

    ax.tick_params(axis='both', which='major', length=6, width=1, colors='black', direction='out')
    ax.tick_params(axis='both', which='minor', length=3, width=1, colors='black', direction='out')

    ax.set_xlim(x_limits)
    ax.set_ylim(y_limits)
    ax.set_aspect('equal')

def plot_curve(curve, n_points=500, n_equipartition=None, title='Parametric Curve', x_limits=(-1.5, 1.5), y_limits=(-0.5, 2)):
    t_vals = np.linspace(curve.t_min, curve.t_max, n_points)
    x_vals = curve.x(t_vals)
    y_vals = curve.y(t_vals)

    plt.figure(figsize=(8, 8), facecolor='white')
    ax = plt.gca()

    plt.plot(x_vals, y_vals, color="#2196F3", linewidth=2.5, zorder=3)

    # Plot equipartition points if requested
    if n_equipartition is not None:
        partition_points = curve.equipartition(n_equipartition)
        x_points = [curve.x(t) for t in partition_points]
        y_points = [curve.y(t) for t in partition_points]
        plt.scatter(x_points, y_points, color="#1565C0", s=40, zorder=4)

    style_plot(ax, x_limits, y_limits)
    plt.title(title, fontsize=14, fontweight='bold', pad=20)
    plt.show()

def animate_curve(curve, n_frames=100, filename='animation.mp4', x_limits=(-1.5, 1.5), y_limits=(-0.5, 2), xticks=None, yticks=None):
    # Original speed parameterization
    t_values_original = np.linspace(curve.t_min, curve.t_max, n_frames)
    x_original = curve.x(t_values_original)
    y_original = curve.y(t_values_original)

    # Constant speed parameterization
    t_values_constant = curve.equipartition(n_frames)
    x_constant = [curve.x(t) for t in t_values_constant]
    y_constant = [curve.y(t) for t in t_values_constant]

    # Set up the figure
    fig = plt.figure(figsize=(16, 8), facecolor='white')
    ax1 = fig.add_subplot(121)
    ax2 = fig.add_subplot(122)

    # Plot the curves
    ax1.plot(x_original, y_original, color="#2196F3", linewidth=2.5, zorder=3)
    ax2.plot(x_constant, y_constant, color="#2196F3", linewidth=2.5, zorder=3)

    # Initialize the points
    point1, = ax1.plot([], [], 'o', color="#1565C0", markersize=8, zorder=4)
    point2, = ax2.plot([], [], 'go', markersize=8, zorder=4)

    style_plot(ax1, x_limits, y_limits, adjust_tick_labels=True)
    style_plot(ax2, x_limits, y_limits, adjust_tick_labels=True)

    if xticks is not None:
        ax1.set_xticks(xticks)
        ax2.set_xticks(xticks)
        ax1.set_xticklabels([f"{x:.1f}" for x in xticks])
        ax2.set_xticklabels([f"{x:.1f}" for x in xticks])
    if yticks is not None:
        ax1.set_yticks(yticks)
        ax2.set_yticks(yticks)
        ax1.set_yticklabels([f"{y:.1f}" for y in yticks])
        ax2.set_yticklabels([f"{y:.1f}" for y in yticks])

    ax1.set_title("Original Speed", fontsize=12, fontweight='bold', pad=15)
    ax2.set_title("Constant Speed", fontsize=12, fontweight='bold', pad=15)
    plt.tight_layout()

    # Update functions
    def update(frame):
        # Update original speed point
        point1.set_data(x_original[:frame], y_original[:frame])
        # Update constant speed point
        point2.set_data(x_constant[:frame], y_constant[:frame])
        return point1, point2

    ani = animation.FuncAnimation(fig, update, frames=n_frames, interval=200, blit=True)
    # Save the animation
    ani.save(filename, writer='ffmpeg')
    plt.show()

def compare_performance(curve, target_length):
    start_time_bisection = time.time()
    bisection_result = curve.bisection_find_t(target_length)
    bisection_time = time.time() - start_time_bisection

    start_time_newton = time.time()
    newton_result = curve.newton_find_t(target_length)
    newton_time = time.time() - start_time_newton

    print(f"Bisection Method Result: {bisection_result:.9f} Time: {bisection_time:.9f} seconds")
    print(f"Newton's Method Result: {newton_result:.9f} Time: {newton_time:.9f} seconds")

# Compute total arc length of the first curve
total_length1 = curve1.total_length()
print(f"Arc Length from t=0 to t=1: {total_length1:.6f}")

# Compare performance of root-finding methods on the first curve
print("\nComparing Performance of Bisection and Newton's Methods:")
compare_performance(curve1, total_length1 / 2)

# Plot the first curve with equipartition points (n=4 and n=20)
plot_curve(curve1, n_points=500, n_equipartition=4, title='Curve with 4 Equipartition Points')
plot_curve(curve1, n_points=500, n_equipartition=20, title='Curve with 20 Equipartition Points')

# Animate the first curve
animate_curve(curve1, n_frames=25, filename='combined_animation.mp4')

# Adjusted ticks
xticks = np.arange(0, 1.1, 0.2)
yticks = np.arange(0, 1.1, 0.2)

# Animate the second curve
animate_curve(curve2, n_frames=200, filename='custom_path_animation.mp4', x_limits=(0, 1), y_limits=(0, 1), xticks=xticks, yticks=yticks)

```
